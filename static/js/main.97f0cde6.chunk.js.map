{"version":3,"sources":["PathfinderVisualization/Node/Node.js","Algos/Dijkstra.js","Algos/AStar.js","Algos/BreadthFirstSearch.js","Algos/DepthFirstSearch.js","Algos/GreedyBestFirstSearch.js","PathfinderVisualization/Pathfinder.js","App.js","serviceWorker.js","index.js"],"names":["Pathfinder","props","state","this","col","isFinish","isStart","isWall","onMouseOut","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","getNeighbors","currentNode","grid","GRID_LENGTH","GRID_WIDTH","neighbors","x","y","push","DFS","startN","nodesToVisit","helperDFS","nodesVisited","length","visited","shortest","i","neighbor","isVisited","previousNode","recursiveResult","undefined","pop","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","mouseIsPressed","nodeBeforeEnter","handleMouseEnter","startNodeMove","finishNodeMove","document","getElementById","handleMouseOut","handleMouseDown","setState","handleMouseUp","visualizeDepthFirstSearch","gridClear","clearPath","lastAlgo","disableElements","startNode","path","displayAlgoNoPath","displayAlgo","visualizeGreedyBestFirstSearch","visitedNodes","shortestPath","sort","nodeA","nodeB","distance","shift","current","surroundingNodes","distanceFromEndNode","Math","abs","GBFS","reverse","visualizeBreadthFirstSearch","BFS","visualizeAStar","distanceFromStartNode","aStar","visualizeDijkstra","dijkstra","j","Infinity","clearGrid","formulateGrid","nodes","createNode","beingUsed","windowWidth","window","screen","width","windowHeight","height","floor","console","log","gridDrawn","addEventListener","removeEventListener","newGrid","slice","node","newNode","setTimeout","enableElements","visualizeShortestPath","onClick","map","rowIdx","key","nodeIdx","setAttribute","classList","add","removeAttribute","remove","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.97f0cde6.chunk.js","sourcesContent":["import React, {Component} from 'react'\r\nimport './Node.css';\r\nexport default class Pathfinder extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n    render() {\r\n        const {\r\n            col,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            onMouseOut,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            row          \r\n          } = this.props;\r\n\r\n          let extraClassName = '';\r\n          if(isFinish) {\r\n            extraClassName = 'node-finish';\r\n          } else if (isStart) {\r\n            extraClassName = 'node-start';\r\n          } else if(isWall) {\r\n            extraClassName = 'node-wall';\r\n          }\r\n          return (\r\n            <div\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseOut={() => onMouseOut(row,col)}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp(row,col)}>\r\n            </div>\r\n          );\r\n    }\r\n}","const NORTH = -1;\r\nconst EAST = 1;\r\nconst SOUTH = 1;\r\nconst WEST = -1;\r\n\r\nexport function dijkstra(grid, startN, GRID_LENGTH, GRID_WIDTH) {\r\n    let nodesToVisit = [];\r\n    let visitedNodes = [];\r\n    let shortestPath = [];\r\n    \r\n    // set the start node\r\n    let startNode = grid[startN.row][startN.col];\r\n\r\n    // push the first node into the array of nodes to explore\r\n    startNode.distance = 0;\r\n    startNode.isVisited = true;\r\n    nodesToVisit.push(startNode);\r\n\r\n    // while there are more nodes to explore\r\n    while(nodesToVisit.length !== 0) {\r\n      // sort\r\n      nodesToVisit.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n      // take the first node out\r\n      let currentNode = nodesToVisit.shift();\r\n      // if its the finish node, return\r\n      if(currentNode.isFinish) {\r\n        shortestPath.push(currentNode);\r\n        let current = currentNode.previousNode;\r\n        while(current !== null) {\r\n          shortestPath.push(current);\r\n          current = current.previousNode;\r\n        }\r\n        break;\r\n      }\r\n      if(currentNode.isWall) continue;\r\n      let surroundingNodes = getNeighbors(currentNode,grid,GRID_LENGTH,GRID_WIDTH);\r\n\r\n      for(let i = 0; i < surroundingNodes.length; i++) {\r\n\r\n        if(!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n          let neighbor = surroundingNodes[i];\r\n          if(!neighbor.isVisited) {\r\n            // set previous node accordingly and push all of neighbors into the array to be visited\r\n            neighbor.previousNode = currentNode;\r\n            neighbor.distance = currentNode.distance + 1;\r\n            neighbor.isVisited = true;\r\n            nodesToVisit.push(neighbor);\r\n          }\r\n        }\r\n      }\r\n      visitedNodes.push(currentNode);\r\n    }\r\n    // return the path and shortest path calculated\r\n    let path = {\r\n        visited : visitedNodes,\r\n        shortest: shortestPath\r\n    }\r\n    return path;\r\n}\r\n\r\nfunction getNeighbors(currentNode, grid,GRID_LENGTH,GRID_WIDTH) {\r\n    let neighbors = [];\r\n    let x = currentNode.row;\r\n    let y = currentNode.col;\r\n\r\n    if(x > 0 && y > 0 && y < GRID_LENGTH - 1 && x < GRID_WIDTH -1 ) {\r\n      neighbors.push(grid[x + NORTH][y]);\r\n      neighbors.push(grid[x][y + EAST]);\r\n      neighbors.push(grid[x + SOUTH][y]);\r\n      neighbors.push(grid[x][y + WEST]);\r\n    } else if(x === 0 && y === 0) {\r\n      neighbors.push(grid[x][y + EAST]);\r\n      neighbors.push(grid[x + SOUTH][y]);\r\n    } else if(x === 0 && y === GRID_LENGTH - 1) {\r\n      neighbors.push(grid[x][y + WEST]);\r\n      neighbors.push(grid[x + SOUTH][y]);\r\n    } else if(x === GRID_WIDTH - 1 && y === 0) {\r\n      neighbors.push(grid[x + NORTH][y]);\r\n      neighbors.push(grid[x][y + EAST]);\r\n    } else if(x === GRID_WIDTH - 1 && y === GRID_LENGTH - 1) {\r\n      neighbors.push(grid[x + NORTH][y]);\r\n      neighbors.push(grid[x][y + WEST]);\r\n    } else if(y === 0 && x > 0 && x < GRID_WIDTH - 1) {\r\n      neighbors.push(grid[x + NORTH][y]);\r\n      neighbors.push(grid[x][y + EAST]);\r\n      neighbors.push(grid[x + SOUTH][y]);\r\n    } else if (x === 0 && y > 0 && y < GRID_LENGTH - 1) {\r\n      neighbors.push(grid[x][y + EAST]);\r\n      neighbors.push(grid[x + SOUTH][y]);\r\n      neighbors.push(grid[x][y + WEST]);\r\n    } else if (y === GRID_LENGTH - 1 && x > 0 && x < GRID_WIDTH - 1) {\r\n      neighbors.push(grid[x + NORTH][y]);\r\n      neighbors.push(grid[x + SOUTH][y]);\r\n      neighbors.push(grid[x][y + WEST]);\r\n    } \r\n    else if(x === GRID_WIDTH - 1 && y > 0 && y < GRID_LENGTH - 1) {\r\n      neighbors.push(grid[x + NORTH][y]);\r\n      neighbors.push(grid[x][y + EAST]);\r\n      neighbors.push(grid[x][y + WEST]);\r\n    }\r\n    return (\r\n      neighbors\r\n    );\r\n  }","// determines which direction to go in the 2D array\r\nconst NORTH = -1;\r\nconst EAST = 1;\r\nconst SOUTH = 1;\r\nconst WEST = -1;\r\n\r\n\r\n// A* algo\r\nexport function aStar(grid, startN, GRID_LENGTH, GRID_WIDTH,FINISH_NODE_ROW,FINISH_NODE_COL,) {\r\n  // get the position of the start node\r\n    const START_NODE_ROW = startN.row;\r\n    const START_NODE_COL = startN.col;\r\n    let nodesToVisit = [];\r\n    let visitedNodes = [];\r\n    let shortestPath = [];\r\n    let startNode = grid[startN.row][startN.col];\r\n\r\n    // push the start node into the array to be explored\r\n    startNode.distance = 0;\r\n    startNode.isVisited = true;\r\n    nodesToVisit.push(startNode);\r\n\r\n    // while array containing the nodes to be explored is not empty\r\n    while(nodesToVisit.length !== 0) {\r\n      // sort the array\r\n      nodesToVisit.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n      // take the first element out of the array\r\n      let currentNode = nodesToVisit.shift();\r\n      // check if the current node is the finish node\r\n      if(currentNode.isFinish) {\r\n        let current = currentNode;\r\n        // if it is, get the shortest path\r\n        while(current !== null) {\r\n          shortestPath.push(current);\r\n          current = current.previousNode;\r\n        }\r\n        // end the loop\r\n        break;\r\n      }\r\n      // if the currenNode is a wall, dont do anything\r\n      if(currentNode.isWall) continue;\r\n\r\n      // get the nodes surrounding the currentNode\r\n      let surroundingNodes = getNeighbors(currentNode,grid,GRID_LENGTH,GRID_WIDTH);\r\n      \r\n      // for every neighbor\r\n      for(let i = 0; i < surroundingNodes.length; i++) {\r\n        // if the node is not a wall and is not the start node\r\n        if(!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n          let neighbor = surroundingNodes[i];\r\n          // if the neighbor has not already been visited\r\n          if(!neighbor.isVisited) {\r\n            // get the distance between current node and end node (H cost)\r\n            let distanceFromEndX = (Math.abs(FINISH_NODE_ROW - neighbor.row)) * 10;\r\n            let distanceFromEndY = (Math.abs(FINISH_NODE_COL - neighbor.col)) * 10;\r\n            let distanceFromEndNode = distanceFromEndX  + distanceFromEndY;\r\n\r\n            // set the previous node equal to the current node\r\n            neighbor.previousNode = currentNode;\r\n\r\n            // get the g cost, determined by a nodes distance from the start node\r\n            let distanceFromStartX = (Math.abs(START_NODE_ROW - neighbor.row)) * 10;\r\n            let distanceFromStartY = (Math.abs(START_NODE_COL - neighbor.col)) * 10;\r\n            let distanceFromStartNode = distanceFromStartX  + distanceFromStartY;\r\n\r\n            // A* is calculated by adding Gcost with Hcost\r\n            neighbor.distance = distanceFromStartNode + distanceFromEndNode;\r\n            neighbor.isVisited = true;\r\n            nodesToVisit.push(neighbor);\r\n          }\r\n        }\r\n      }\r\n      // push currentNode into the visited array\r\n      visitedNodes.push(currentNode);\r\n    }\r\n    // return the path and the shortest path\r\n    let path = {\r\n        visited : visitedNodes,\r\n        shortest: shortestPath\r\n    }\r\n    return path;\r\n}\r\n\r\n// get the neighbors surrounding a node\r\nfunction getNeighbors(currentNode, grid,GRID_LENGTH,GRID_WIDTH) {\r\n  let neighbors = [];\r\n  let x = currentNode.row;\r\n  let y = currentNode.col;\r\n\r\n  if(x > 0 && y > 0 && y < GRID_LENGTH - 1 && x < GRID_WIDTH -1 ) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if(x === 0 && y === 0) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if(x === 0 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + WEST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if(x === GRID_WIDTH - 1 && y === 0) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n  } else if(x === GRID_WIDTH - 1 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if(y === 0 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if (x === 0 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if (y === GRID_LENGTH - 1 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } \r\n  else if(x === GRID_WIDTH - 1 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  }\r\n  return (\r\n    neighbors\r\n  );\r\n}","const NORTH = -1;\r\nconst EAST = 1;\r\nconst SOUTH = 1;\r\nconst WEST = -1;\r\n\r\n// Breadth first search\r\nexport function BFS(grid, startN, GRID_LENGTH, GRID_WIDTH) {\r\n    let nodesToVisit = [];\r\n    let visitedNodes = [];\r\n    let shortestPath = [];\r\n    let startNode = grid[startN.row][startN.col];\r\n\r\n    // push the start node into the array to be explored\r\n    startNode.distance = 0;\r\n    startNode.isVisited = true;\r\n    nodesToVisit.push(startNode);\r\n\r\n    // while there are still nodes to be explored\r\n    while(nodesToVisit.length !== 0) {\r\n      // take the first node from the front of the array\r\n      let currentNode = nodesToVisit.shift();\r\n      if(currentNode.isFinish) {\r\n        //calculate shortest path\r\n        shortestPath.push(currentNode);\r\n        let current = currentNode.previousNode;\r\n        while(current !== null) {\r\n          shortestPath.push(current);\r\n          current = current.previousNode;\r\n        }\r\n        break;\r\n      }\r\n      // if the node is a wall, dont do anything\r\n      if(currentNode.isWall) continue;\r\n\r\n      //get the neighbors surrounding the node\r\n      let surroundingNodes = getNeighbors(currentNode,grid,GRID_LENGTH,GRID_WIDTH);\r\n\r\n      // for each surrounding node\r\n      for(let i = 0; i < surroundingNodes.length; i++) {\r\n        // if the node is not a wall and is not the start node\r\n        if(!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n          let neighbor = surroundingNodes[i];\r\n          // if the node has not been visited\r\n          if(!neighbor.isVisited) {\r\n            // calculate distance and push node into the array of nodes to be visited\r\n            neighbor.previousNode = currentNode;\r\n            neighbor.distance = currentNode.distance + 1;\r\n            neighbor.isVisited = true;\r\n            nodesToVisit.push(neighbor);\r\n          }\r\n        }\r\n      }\r\n      // done with node\r\n      visitedNodes.push(currentNode);\r\n    }\r\n    // return the path and the shortest path\r\n    let path = {\r\n        visited : visitedNodes,\r\n        shortest: shortestPath\r\n    }\r\n    return path;\r\n}\r\n\r\nfunction getNeighbors(currentNode, grid,GRID_LENGTH,GRID_WIDTH) {\r\n  let neighbors = [];\r\n  let x = currentNode.row;\r\n  let y = currentNode.col;\r\n\r\n  if(x > 0 && y > 0 && y < GRID_LENGTH - 1 && x < GRID_WIDTH -1 ) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if(x === 0 && y === 0) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if(x === 0 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + WEST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if(x === GRID_WIDTH - 1 && y === 0) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n  } else if(x === GRID_WIDTH - 1 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if(y === 0 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if (x === 0 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if (y === GRID_LENGTH - 1 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } \r\n  else if(x === GRID_WIDTH - 1 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  }\r\n  return (\r\n    neighbors\r\n  );\r\n}","const NORTH = -1;\r\nconst EAST = 1;\r\nconst SOUTH = 1;\r\nconst WEST = -1;\r\n\r\n// depth first search\r\nexport function DFS(grid, startN, GRID_LENGTH, GRID_WIDTH) {\r\n  // push the first node into the array containing the nodes to be explored\r\n    let nodesToVisit = [];\r\n    nodesToVisit.push(startN);\r\n    let nodesVisited = [];\r\n    let path = helperDFS(grid,GRID_LENGTH,GRID_WIDTH,nodesToVisit,nodesVisited);\r\n    return path;\r\n}\r\n\r\n// recursive implementation\r\nfunction helperDFS(grid,GRID_LENGTH,GRID_WIDTH,nodesToVisit,nodesVisited) {\r\n  // if there are more nodes to visit and the node to explore next is the end node, return the path found\r\n    if(nodesToVisit.length !== 0 && nodesToVisit[nodesToVisit.length - 1].isFinish) {\r\n        let path = {\r\n          visited : nodesVisited,\r\n          shortest: nodesToVisit\r\n        }\r\n        return path;\r\n    }\r\n    // if there are no more nodes to visit, terminate\r\n    else if(nodesToVisit.length === 0) {\r\n        let path= {\r\n          visited : nodesVisited,\r\n          shortest: null\r\n        }\r\n        return path;\r\n    }\r\n    else {\r\n      // get the current node to be explored next\r\n        let currentNode = nodesToVisit[nodesToVisit.length - 1];\r\n        // get the nodes surrounding the current node\r\n        let neighbors = getNeighbors(currentNode,grid,GRID_LENGTH,GRID_WIDTH);\r\n        // for every neighbor\r\n        for(let i = 0; i < neighbors.length; i++) {\r\n          // if the neighbor is not a wall and is not the start node\r\n            if(!neighbors[i].isWall && !neighbors[i].isStart) {\r\n              // get the current neighbor\r\n                let neighbor = neighbors[i];\r\n                // if the node has not aleady been visited\r\n                if(!neighbor.isVisited) {\r\n                  // set the previous node to be the current node\r\n                    neighbor.previousNode = currentNode;\r\n                    neighbor.isVisited = true;\r\n                    // push the neighbor into the nodes to visit and the nodes visited array\r\n                    nodesVisited.push(neighbor);\r\n                    nodesToVisit.push(neighbor);\r\n                    // recurse\r\n\r\n                    // get the result\r\n                    let recursiveResult = helperDFS(grid,GRID_LENGTH,GRID_WIDTH,nodesToVisit,nodesVisited);\r\n                    if(recursiveResult === undefined) {\r\n                      continue;\r\n                    }\r\n                    // return the result if not null and undefined\r\n                    else if (recursiveResult.shortest !== null && recursiveResult.shortest !== undefined) {\r\n                        return recursiveResult;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // pop the last element out of the nodesToVisit array (element being explored)\r\n        nodesToVisit.pop();\r\n        return helperDFS(grid,GRID_LENGTH,GRID_WIDTH,nodesToVisit,nodesVisited);\r\n    }\r\n}\r\n\r\n// get the neighbors surrounding a particular node\r\nfunction getNeighbors(currentNode, grid,GRID_LENGTH,GRID_WIDTH) {\r\n  let neighbors = [];\r\n  let x = currentNode.row;\r\n  let y = currentNode.col;\r\n\r\n  if(x > 0 && y > 0 && y < GRID_LENGTH - 1 && x < GRID_WIDTH -1 ) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if(x === 0 && y === 0) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if(x === 0 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + WEST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if(x === GRID_WIDTH - 1 && y === 0) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n  } else if(x === GRID_WIDTH - 1 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if(y === 0 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if (x === 0 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if (y === GRID_LENGTH - 1 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } \r\n  else if(x === GRID_WIDTH - 1 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  }\r\n  return (\r\n    neighbors\r\n  );\r\n}","const NORTH = -1;\r\nconst EAST = 1;\r\nconst SOUTH = 1;\r\nconst WEST = -1;\r\n\r\n// Greedier version of A*\r\nexport function GBFS(grid, startN, GRID_LENGTH, GRID_WIDTH,FINISH_NODE_ROW,FINISH_NODE_COL) {\r\n    let nodesToVisit = [];\r\n    let visitedNodes = [];\r\n    let shortestPath = [];\r\n    let startNode = grid[startN.row][startN.col];\r\n\r\n    startNode.isVisited = true;\r\n    nodesToVisit.push(startNode);\r\n\r\n    while(nodesToVisit.length !== 0) {\r\n      nodesToVisit.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n      let currentNode = nodesToVisit.shift();\r\n      if(currentNode.isFinish) {\r\n        shortestPath.push(currentNode);\r\n        let current = currentNode.previousNode;\r\n        while(current !== null) {\r\n          shortestPath.push(current);\r\n          current = current.previousNode;\r\n        }\r\n        break;\r\n      }\r\n\r\n      if(currentNode.isWall) continue;\r\n\r\n      let surroundingNodes = getNeighbors(currentNode,grid,GRID_LENGTH,GRID_WIDTH);\r\n      for(let i = 0; i < surroundingNodes.length; i++) {\r\n        if(!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n          let neighbor = surroundingNodes[i];\r\n          if(!neighbor.isVisited) {\r\n            // get the distance between current node and end node (H cost)\r\n            let distanceFromEndX = (Math.abs(FINISH_NODE_ROW - neighbor.row)) * 10;\r\n            let distanceFromEndY = (Math.abs(FINISH_NODE_COL - neighbor.col)) * 10;\r\n            let distanceFromEndNode = distanceFromEndX + distanceFromEndY;\r\n\r\n            // Greedy best first search only takes into account distance from end node\r\n            // when calculating cost. Thus f(n) = h(n)\r\n            neighbor.previousNode = currentNode;\r\n            neighbor.distance = distanceFromEndNode;\r\n            neighbor.isVisited = true;\r\n            nodesToVisit.push(neighbor);\r\n          }\r\n        }\r\n      }\r\n      visitedNodes.push(currentNode);\r\n    }\r\n    let path = {\r\n        visited : visitedNodes,\r\n        shortest: shortestPath\r\n    }\r\n    return path;\r\n}\r\nfunction getNeighbors(currentNode, grid,GRID_LENGTH,GRID_WIDTH) {\r\n  let neighbors = [];\r\n  let x = currentNode.row;\r\n  let y = currentNode.col;\r\n\r\n  if(x > 0 && y > 0 && y < GRID_LENGTH - 1 && x < GRID_WIDTH -1 ) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if(x === 0 && y === 0) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if(x === 0 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + WEST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if(x === GRID_WIDTH - 1 && y === 0) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n  } else if(x === GRID_WIDTH - 1 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if(y === 0 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if (x === 0 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if (y === GRID_LENGTH - 1 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } \r\n  else if(x === GRID_WIDTH - 1 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  }\r\n  return (\r\n    neighbors\r\n  );\r\n}","import React, {Component} from 'react'\r\nimport Node from './Node/Node'\r\nimport {dijkstra} from '../Algos/Dijkstra';\r\nimport {aStar} from '../Algos/AStar';\r\nimport {BFS} from '../Algos/BreadthFirstSearch';\r\nimport {DFS} from '../Algos/DepthFirstSearch';\r\nimport {GBFS} from '../Algos/GreedyBestFirstSearch';\r\n\r\nimport './Pathfinder.css';\r\n\r\nlet START_NODE_ROW = 10;\r\nlet START_NODE_COL = 10;\r\nlet FINISH_NODE_ROW = 10;\r\nlet FINISH_NODE_COL = 45;\r\n\r\nlet mouseIsPressed = false;\r\n\r\n// 0 = regular node, 1 = wall\r\nlet nodeBeforeEnter = -1;\r\n\r\nlet GRID_WIDTH = 20;\r\nlet GRID_LENGTH = 50;\r\n\r\n\r\nexport default class Pathfinder extends Component {\r\n  // last algo: 0= A*, 1 = Greedy, 2= Dijkstra, 3=Breadth, 4 = Depth\r\n  constructor(props) {\r\n      super(props);\r\n      this.state = {\r\n          grid:[],\r\n          gridClear: true,\r\n          beingUsed: false,\r\n          finishNodeMove: false,\r\n          startNodeMove: false,\r\n          finishNodeMove: false,\r\n          lastAlgo: -1,\r\n      };\r\n  }\r\n\r\n  // set the grid and also set up a mouseUp listener\r\n  componentDidMount() {\r\n      let windowWidth = window.screen.width;\r\n      let windowHeight = window.screen.height;\r\n      GRID_LENGTH = ((windowWidth - 50) / 25);\r\n      GRID_WIDTH = ((windowHeight - 300) / 25);\r\n      START_NODE_ROW = Math.floor(GRID_WIDTH / 2);\r\n      FINISH_NODE_ROW = Math.floor(GRID_WIDTH / 2);\r\n      START_NODE_COL =  Math.floor(GRID_LENGTH / 4);\r\n      FINISH_NODE_COL = Math.floor(GRID_LENGTH * (4/5));\r\n      console.log(START_NODE_ROW);\r\n      const gridDrawn = this.formulateGrid();\r\n      this.setState({\r\n        grid: gridDrawn\r\n      });\r\n      window.addEventListener('mouseup', this.onMouseUp)\r\n\r\n  }\r\n\r\n  // detech mouseUp listener\r\n  componentWillUnmount() {\r\n    window.removeEventListener('mouseup', this.onMouseUp)\r\n  }\r\n\r\n  // set mouseIsPressed to false\r\n  onMouseUp = () => {\r\n    mouseIsPressed = false\r\n  }\r\n\r\n  // if mouse enters the boundary of any node\r\n  handleMouseEnter = (row,col) => {\r\n    // use this to take the state of the node back to what it was\r\n    if(this.state.grid[row][col].isWall) {\r\n      nodeBeforeEnter = 1;\r\n    } else {\r\n      nodeBeforeEnter = 0;\r\n    }\r\n    // if dragging to make walls\r\n    if(!this.state.grid[row][col].isFinish && !this.state.grid[row][col].isStart && mouseIsPressed\r\n        && !this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      if(!this.state.grid[row][col].isWall) {\r\n        // turn the nodes into wall nodes\r\n        this.state.grid[row][col].isWall = true;\r\n        this.state.grid[row][col].isVisited = false;\r\n        document.getElementById(`node-${row}-${col}`).className = \"node node-wall\";\r\n\r\n      } else {\r\n        // turn the wall nodes back into regular nodes\r\n        this.state.grid[row][col].isWall = false;\r\n        this.state.grid[row][col].isVisited = false;\r\n        document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n      }\r\n    } else if(this.state.startNodeMove && !this.state.grid[row][col].isFinish) {\r\n      // if the start node is being dragged, set the nodes in the array accordingly and then\r\n      // set the row and column of where the start node is\r\n      this.state.grid[row][col].isStart = true;\r\n      this.state.grid[row][col].isWall = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\r\n      START_NODE_ROW = row;\r\n      START_NODE_COL = col;\r\n\r\n    } else if(this.state.finishNodeMove && !this.state.grid[row][col].isStart) {\r\n      // if the finish node is moving, do the same thing as described above\r\n      this.state.grid[row][col].isFinish = true;\r\n      this.state.grid[row][col].isWall = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\r\n      FINISH_NODE_ROW = row;\r\n      FINISH_NODE_COL = col;\r\n    }\r\n  }\r\n\r\n  // when the mouse leaves a certain node\r\n  handleMouseOut = (row,col) => {\r\n    // if the start node is moving\r\n    if(this.state.startNodeMove && !this.state.grid[row][col].isFinish) {\r\n      // set this node back into a regular node\r\n      this.state.grid[row][col].isStart = false;\r\n      this.state.grid[row][col].isFinish = false;\r\n      this.state.grid[row][col].isWall = false;\r\n      this.state.grid[row][col].isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n    }\r\n    else if(this.state.finishNodeMove && !this.state.grid[row][col].isStart) {\r\n      // if finish node has moved out of this node, put node back into regular node\r\n      this.state.grid[row][col].isStart = false;\r\n      this.state.grid[row][col].isFinish = false;\r\n      this.state.grid[row][col].isWall = false;\r\n      this.state.grid[row][col].isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n    }\r\n    if(nodeBeforeEnter === 1 && (this.state.startNodeMove || this.state.finishNodeMove)) {\r\n      // if the node was orinally a wall before the start/end node moved into it, set it\r\n      // back into a wall\r\n      this.state.grid[row][col].isWall = true;\r\n      this.state.grid[row][col].isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node node-wall\";\r\n    }  \r\n  }\r\n\r\n  // toggle a given wall\r\n  toggleWall(row,col,grid) {\r\n    // make a copy\r\n    let newGrid = grid.slice();\r\n    let node = grid[row][col];\r\n    let newNode = {\r\n      ... node,\r\n      isWall: !node.isWall\r\n    }\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  handleMouseDown = (row,col) => {\r\n    // set the state of a particular node based on its current status of \r\n    // being a wall node or regular node\r\n    if(!this.state.grid[row][col].isFinish && !this.state.grid[row][col].isStart && \r\n      !this.state.grid[row][col].isWall) {\r\n      // turn the node into a wall node and indicate that the mouse is currently being pressed\r\n      mouseIsPressed = true;\r\n      this.state.grid[row][col].isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \r\n      \"node node-wall\";\r\n      this.state.grid[row][col].isWall = true;\r\n    } \r\n    else if(!this.state.grid[row][col].isFinish && !this.state.grid[row][col].isStart && \r\n      this.state.grid[row][col].isWall) {\r\n      // turn the node back into a regular node and indicate that the mouse is being pressed\r\n      mouseIsPressed = true;\r\n      this.state.grid[row][col].isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n      this.state.grid[row][col].isWall = false;\r\n\r\n    }else if (this.state.grid[row][col].isStart) {\r\n      // if the user is pressed on the start node, indicate that the start node is moving\r\n      this.setState({\r\n        startNodeMove: true\r\n      });\r\n    } else if (this.state.grid[row][col].isFinish) {\r\n      // if the user is pressed on the finish  node, indicate that the finish node is moving\r\n      this.setState({\r\n        finishNodeMove: true\r\n      });\r\n    }\r\n  }\r\n\r\n  handleMouseUp = (row,col) => {\r\n    // if the mouse is released\r\n\r\n    // the start and finish node are not being moved\r\n    this.setState({\r\n      startNodeMove:false,\r\n      finishNodeMove: false\r\n    });\r\n    // if the end node is not the start or finish node\r\n    if(!this.state.grid[row][col].isStart && !this.state.grid[row][col].isFinish) {\r\n      if(this.state.startNodeMove) {\r\n        // set the previous start node into a regular node\r\n        this.state.grid[START_NODE_ROW][START_NODE_COL].isStart = false;\r\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className =\r\n            'node';\r\n        \r\n        // update start node\r\n        this.state.grid[row][col].isStart = true;\r\n        this.state.grid[row][col].isVisited = false;\r\n        this.state.grid[row][col].isWall = false;\r\n        // update the position of the start node\r\n        START_NODE_ROW = row;\r\n        START_NODE_COL = col;\r\n      } else if (this.state.finishNodeMove) {\r\n        // do the same thing as done for start node above\r\n        this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = false;\r\n        document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className =\r\n            'node';\r\n  \r\n        this.state.grid[row][col].isFinish = true;\r\n        this.state.grid[row][col].isVisited = false;\r\n        this.state.grid[row][col].isWall = false;\r\n  \r\n        FINISH_NODE_ROW = row;\r\n        FINISH_NODE_COL = col;\r\n      }\r\n    }\r\n    // if the start or end node is moving, update accoridingly\r\n    if(this.state.startNodeMove) {\r\n        START_NODE_ROW = row;\r\n        START_NODE_COL = col;\r\n    } else if(this.state.finishNodeMove) {\r\n        FINISH_NODE_ROW = row;\r\n        FINISH_NODE_COL = col;\r\n    }\r\n\r\n    // if the finish node is on top of the start node\r\n    if(START_NODE_COL === FINISH_NODE_COL && START_NODE_ROW === FINISH_NODE_ROW) {\r\n      // reset the nodes to their original positions\r\n      this.state.grid[row][col].isFinish = false;\r\n      this.state.grid[row][col].isVisited = false;\r\n      this.state.grid[row][col].isStart = false;\r\n      this.state.grid[row][col].isWall = false;\r\n      document.getElementById(`node-${row}-${col}`).className =\r\n      'node';\r\n\r\n      START_NODE_ROW = 10;\r\n      START_NODE_COL = 10;\r\n      FINISH_NODE_ROW = 10;\r\n      FINISH_NODE_COL = 45;\r\n\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isWall = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isVisited = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isFinish = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isStart = true;\r\n      document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className =\r\n      'node node-start';\r\n\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isWall = false;\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isVisited = false;\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = true;\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isStart = false;\r\n      document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`).className =\r\n      'node node-finish';\r\n    }\r\n    mouseIsPressed = false;\r\n\r\n  }\r\n\r\n  // visualize depth first search algo\r\n  visualizeDepthFirstSearch = () => {\r\n    // only execute if the stat and end node are not moving\r\n    if(!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      // if the grid is not clear, clear the grid\r\n      if(!this.state.gridClear) {\r\n        this.clearPath();\r\n      }\r\n      this.setState({\r\n        lastAlgo:4\r\n      });\r\n      // disable all elements when visualizing\r\n      this.disableElements();\r\n      // get the start node\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      // get the path returned\r\n      let path = DFS(this.state.grid,startNode,GRID_LENGTH,GRID_WIDTH);\r\n      // visualize the path\r\n      if(path.shortest === null) {\r\n        this.displayAlgoNoPath(path.visited);\r\n      } else {\r\n        this.displayAlgo(path.visited,path.shortest);\r\n      }\r\n    }\r\n  }\r\n\r\n  // visualize the greedy best first search algo\r\n  visualizeGreedyBestFirstSearch = () => {\r\n    if(!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      if(!this.state.gridClear) {\r\n      this.clearPath();\r\n      }\r\n      this.setState({\r\n        lastAlgo:1\r\n      })\r\n      this.disableElements();\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      let path = GBFS(this.state.grid,startNode,GRID_LENGTH,GRID_WIDTH,FINISH_NODE_ROW,FINISH_NODE_COL);\r\n      let shortestPath = path.shortest.reverse();\r\n      this.displayAlgo(path.visited,shortestPath);\r\n    }\r\n  }\r\n\r\n  // this is pretty much the same thing as dijkstra's except we are not sorting\r\n  visualizeBreadthFirstSearch = () => {\r\n    if(!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      if(!this.state.gridClear) {\r\n        this.clearPath();\r\n      }\r\n      this.setState({\r\n        lastAlgo:3\r\n      })\r\n      this.disableElements();\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      let path = BFS(this.state.grid,startNode,GRID_LENGTH,GRID_WIDTH);\r\n      let shortestPath = path.shortest.reverse();\r\n      this.displayAlgo(path.visited,shortestPath);\r\n    }\r\n  }\r\n\r\n  // visualize A* algo\r\n  visualizeAStar = () => {\r\n    if(!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      if(!this.state.gridClear) {\r\n        this.clearPath();\r\n      }\r\n      this.setState({\r\n        lastAlgo:0\r\n      })\r\n      this.disableElements();\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      let path = aStar(this.state.grid,startNode,GRID_LENGTH,GRID_WIDTH,FINISH_NODE_ROW,FINISH_NODE_COL);\r\n      let shortestPath = path.shortest.reverse();\r\n      this.displayAlgo(path.visited,shortestPath);\r\n    }\r\n\r\n  }\r\n  \r\n  // visualize Dijkstra's algo\r\n  visualizeDijkstra = () => {\r\n    if(!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      if(!this.state.gridClear) {\r\n        this.clearPath();\r\n      }\r\n      this.setState({\r\n        lastAlgo:2\r\n      })\r\n      this.disableElements();\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      let path = dijkstra(this.state.grid,startNode,GRID_LENGTH,GRID_WIDTH);\r\n      let shortestPath = path.shortest.reverse();\r\n      this.displayAlgo(path.visited,shortestPath);\r\n    }\r\n    \r\n  }\r\n\r\n  // if there is no path found, just display the path visited\r\n  displayAlgoNoPath(nodes) {\r\n    // grid is no longer clear\r\n    this.setState({\r\n      gridClear: false\r\n    });\r\n    for(let i = 0; i <= nodes.length;i++) {\r\n      if(i === nodes.length) {\r\n        setTimeout(() => {\r\n          // enable all the elements again\r\n          this.enableElements();\r\n        }, 6 * i);\r\n      }\r\n      else {\r\n        setTimeout(() => {\r\n        // update the grid\r\n        const node = nodes[i];\r\n        if(!node.isStart && !node.isFinish) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited disabledNode';\r\n        }}, 6 * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  // visualize the path found\r\n  displayAlgo(nodes, shortestPath) {\r\n    for(let i = 0; i <= nodes.length;i++) {\r\n      if(i === nodes.length) {\r\n        // if the other elements are done updating, show the shortest path\r\n          setTimeout(() => {\r\n            this.visualizeShortestPath(shortestPath);\r\n          }, 6 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n        const node = nodes[i];\r\n        if(!node.isStart && !node.isFinish) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          'node node-visited disabledNode';\r\n        }}, 6 * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  // show the shortest path\r\n  visualizeShortestPath(shortestPath) {\r\n    this.setState({\r\n      gridClear: false\r\n    });\r\n    for(let j = 0; j <= shortestPath.length;j++)  {\r\n      if(j === shortestPath.length) {\r\n        setTimeout(() => {\r\n          this.enableElements();\r\n        }, 10 * j);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = shortestPath[j];\r\n          if(!node.isStart && !node.isFinish) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-final-path disabledNode';\r\n          }        \r\n        }, 10 * j);\r\n      }\r\n    }\r\n  };\r\n\r\n  // clear the grid of all path nodes\r\n  clearPath = () => {\r\n    if(!this.state.startNodeMove && !this.state.finishNodeMove) { \r\n      this.setState({\r\n        gridClear: true,\r\n        lastAlgo : -1\r\n      })\r\n      nodeBeforeEnter = -1;\r\n      for(let i = 0; i < GRID_WIDTH; i++) {\r\n        for(let j = 0; j < GRID_LENGTH;j++) {\r\n          if(i === START_NODE_ROW && j === START_NODE_COL) {\r\n            document.getElementById(`node-${i}-${j}`).className = 'node node-start';\r\n            this.state.grid[i][j].distance = Infinity;\r\n            this.state.grid[i][j].isVisited = false;\r\n            this.state.grid[i][j].isWall = false;\r\n            this.state.grid[i][j].previousNode = null;\r\n          } else if(i === FINISH_NODE_ROW && j === FINISH_NODE_COL ) {\r\n            document.getElementById(`node-${i}-${j}`).className = 'node node-finish';\r\n            this.state.grid[i][j].distance = Infinity;\r\n            this.state.grid[i][j].isVisited = false;\r\n            this.state.grid[i][j].isWall = false;\r\n            this.state.grid[i][j].previousNode = null;\r\n          }\r\n          else if(this.state.grid[i][j].isVisited && !this.state.grid[i][j].isFinish) {\r\n            document.getElementById(`node-${i}-${j}`).className = 'node';\r\n            this.state.grid[i][j].distance = Infinity;\r\n            this.state.grid[i][j].isVisited = false;\r\n            this.state.grid[i][j].isWall = false;\r\n            this.state.grid[i][j].previousNode = null;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // clear the grid of all wall and path nodes\r\n  clearGrid = () => {\r\n    if(!this.state.startNodeMove && !this.state.finishNodeMove) { \r\n      this.setState({\r\n        gridClear: true,\r\n        lastAlgo: -1\r\n      })\r\n      nodeBeforeEnter = -1;\r\n      for(let i = 0; i < GRID_WIDTH; i++) {\r\n        for(let j = 0; j < GRID_LENGTH;j++) {\r\n            if(i === START_NODE_ROW && j === START_NODE_COL) {\r\n              document.getElementById(`node-${i}-${j}`).className = 'node node-start';\r\n            } else if(i === FINISH_NODE_ROW && j === FINISH_NODE_COL ) {\r\n              document.getElementById(`node-${i}-${j}`).className = 'node node-finish';\r\n            } else {\r\n              document.getElementById(`node-${i}-${j}`).className = 'node';\r\n            }\r\n            this.state.grid[i][j].distance = Infinity;\r\n            this.state.grid[i][j].isVisited = false;\r\n            this.state.grid[i][j].isWall = false;\r\n            this.state.grid[i][j].previousNode = null;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n      return (\r\n        <>\r\n          <div className=\"buttons\">\r\n            <button id=\"AStar_Visualizer\" className=\"button buttonAlgo\" onClick={this.visualizeAStar}>\r\n              A* Algorithm\r\n            </button>\r\n            <button id=\"GBFS_Visualizer\" className=\"button buttonAlgo\" onClick={this.visualizeGreedyBestFirstSearch}>\r\n              Greedy Best-First Search\r\n            </button>\r\n            <button id=\"Dijkstra_Visualizer\" className=\"button buttonAlgo\" onClick={this.visualizeDijkstra}>\r\n              Dijkstra's Algorithm\r\n            </button>\r\n            <button id=\"BFS_Visualizer\" className=\"button buttonAlgo\" onClick={this.visualizeBreadthFirstSearch}>\r\n              Breadth First Search\r\n            </button>\r\n            <button id=\"DFS_Visualizer\" className=\"button buttonAlgo\" onClick={this.visualizeDepthFirstSearch}>\r\n              Depth First Search\r\n            </button> \r\n            <button id=\"ClearGrid\" className=\"button button-clear buttonClear\" onClick={this.clearGrid}>\r\n              Clear Grid\r\n            </button>\r\n            <button id=\"ClearPath\" className=\"button button-clear buttonClear\" onClick={this.clearPath}>\r\n              Clear Path\r\n            </button>\r\n          </div>\r\n\r\n          <div className=\"legend\">\r\n              <div className=\"fakeNode fakeNodeStart firstFakeNode\"></div>\r\n              <label className=\"fakeNodeLabel\">Start Node</label>\r\n              <div className=\"fakeNode fakeNodeEnd\"></div>\r\n              <label className=\"fakeNodeLabel\">End Node</label>\r\n              <div className=\"fakeNode fakeNodeBlock\"></div>\r\n              <label className=\"fakeNodeLabel\">Wall Node</label>\r\n              <div className=\"fakeNode\"></div>\r\n              <label className=\"fakeNodeLabel\">Unvisted Node</label>\r\n              <div className=\"fakeNode fakeNodeExploredFirst\"></div>\r\n              <div className=\"fakeNode fakeNodeExploredSecond\"></div>\r\n              <label className=\"fakeNodeLabel\">Explored Node</label>\r\n              <div className=\"fakeNode fakeNodeShortestPath\"></div>\r\n              <label className=\"fakeNodeLabel\">Path Found Node</label>\r\n          </div>\r\n\r\n          <div id=\"gridNodes\" className=\"grid\">\r\n            {this.state.grid.map((row, rowIdx) => {\r\n              return (\r\n                <div key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const {\r\n                      row, \r\n                      col, \r\n                      isFinish, \r\n                      isStart, \r\n                      isWall\r\n                    } = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row,col) =>this.handleMouseDown(row, col)}\r\n                        onMouseEnter={(row, col) =>this.handleMouseEnter(row, col)}\r\n                        onMouseUp={(row, col) =>this.handleMouseUp(row, col)}\r\n                        onMouseOut={(row,col) => this.handleMouseOut(row,col)}\r\n                        row={row}></Node>\r\n                    );\r\n                  })}\r\n                </div>  \r\n              );\r\n            })}\r\n          </div>\r\n        </>\r\n      );\r\n    }\r\n    // disable user interaction\r\n    disableElements() {\r\n      document.getElementById(`AStar_Visualizer`).setAttribute(\"disabled\",\"disabled\");\r\n      document.getElementById(`GBFS_Visualizer`).setAttribute(\"disabled\",\"disabled\");\r\n      document.getElementById(`Dijkstra_Visualizer`).setAttribute(\"disabled\",\"disabled\");\r\n      document.getElementById(`BFS_Visualizer`).setAttribute(\"disabled\",\"disabled\");\r\n      document.getElementById(`DFS_Visualizer`).setAttribute(\"disabled\",\"disabled\");\r\n      document.getElementById(`ClearGrid`).setAttribute(\"disabled\",\"disabled\");\r\n      document.getElementById(`ClearPath`).setAttribute(\"disabled\",\"disabled\");\r\n      for(let i = 0; i < GRID_WIDTH; i++) {\r\n        for(let j = 0; j < GRID_LENGTH;j++) {\r\n          document.getElementById(`node-${i}-${j}`).classList.add(\"disabledNode\");\r\n        }\r\n      }\r\n      \r\n    }\r\n\r\n    // enable user interaction\r\n    enableElements() {\r\n      document.getElementById(`AStar_Visualizer`).removeAttribute(\"disabled\");\r\n      document.getElementById(`GBFS_Visualizer`).removeAttribute(\"disabled\");\r\n      document.getElementById(`Dijkstra_Visualizer`).removeAttribute(\"disabled\");\r\n      document.getElementById(`BFS_Visualizer`).removeAttribute(\"disabled\");\r\n      document.getElementById(`DFS_Visualizer`).removeAttribute(\"disabled\");\r\n      document.getElementById(`ClearGrid`).removeAttribute(\"disabled\");\r\n      document.getElementById(`ClearPath`).removeAttribute(\"disabled\");\r\n      for(let i = 0; i < GRID_WIDTH; i++) {\r\n        for(let j = 0; j < GRID_LENGTH;j++) {\r\n          document.getElementById(`node-${i}-${j}`).classList.remove(\"disabledNode\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // generate the beginning grid\r\n    formulateGrid = () => {\r\n        // draw a grid onto the screen\r\n        const nodes = [];\r\n        for(let i = 0; i < GRID_WIDTH; i++) {\r\n            const row = [];\r\n            for(let j = 0; j < GRID_LENGTH;j++) {\r\n                row.push(this.createNode(j,i));\r\n            }\r\n            nodes.push(row);\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    // create a node\r\n    createNode = (col, row) => {\r\n        return {\r\n          col,\r\n          row,\r\n          isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n          isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n          distance: Infinity,\r\n          isVisited: false,\r\n          isWall: false,\r\n          previousNode: null\r\n        };\r\n    };\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport Pathfinder from './PathfinderVisualization/Pathfinder';\r\n\r\n/*\r\n  Big thanks to Clement Mihailescu, who inspired me to do this project!\r\n\r\n  His youtube channel can be found here: https://www.youtube.com/channel/UCaO6VoaYJv4kS-TQO_M-N_g\r\n*/\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App Background\" >\r\n        <h1 className=\"Header\">Pathfinding Visualized</h1>\r\n        <div className=\"Grid\">\r\n          <Pathfinder></Pathfinder>\r\n        </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}