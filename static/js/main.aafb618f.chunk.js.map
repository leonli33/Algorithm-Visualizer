{"version":3,"sources":["assets/brick-wall.png","assets/drop-down-down.png","PathfinderVisualization/Node/Node.js","Functions/functions.js","Maze/PrimsAlgorithm.js","Maze/KruskalsAlgorithm.js","Maze/WilsonsAlgorithm.js","PathfinderVisualization/Components/Legend/Legend.js","PathfinderVisualization/Components/Dropdown/Dropdown.js","PathfinderVisualization/Pathfinder.js","Algos/AStar.js","Algos/GreedyBestFirstSearch.js","Algos/Dijkstra.js","Algos/DepthFirstSearch.js","Maze/RecursiveBacktracking.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","props","React","useState","isHovered","setIsHovered","col","isFinish","isStart","isWall","onMouseOut","onMouseDown","onMouseEnter","onMouseUp","row","nodeWidth","isShortestPathNode","isExploredNode","isNeighborNode","extraClassName","hoverBackgroundColor","typeIndex","startNodeDistance","Math","abs","startNodeRow","startNodeCol","endNodeDistance","finishNodeRow","finishNodeCol","cost","totalCost","id","className","isWallMode","e","isLeftMouseDown","buttons","isShiftKeyDown","shiftKey","gridBeingUsed","onMouseLeave","style","width","height","backgroundColor","zIndex","position","bottom","left","border","display","flexDirection","padding","textAlign","fontSize","justifyContent","color","nodeIndex","pathNodeInbounds","currentNode","length","getNeighbors","grid","neighbors","northNode","eastNode","southNode","westNode","push","generateRandomNumber","lowNum","highNum","floor","random","createNewDirectionMap","directions","Map","set","checkCellInBounds","cell","isStartOrEndNode","startNode","finishNode","getStartCell","startCellRow","startCellCol","getRandomDirection","currentDirections","options","keys","key","getSurroundingCells","currentCell","cellMap","isPath","allVisitedFrontierCells","frontierCells","currentRow","currentCol","numericalIsPath","direction","currentFrontierCell","frontierCell","add","mergeTwoSets","set1","set2","mergedSet","Set","el","getPreviousDirection","cellArr","cell1","cell2","getFullPath","cellArray","isLoopPath","path","i","middleCell","getMiddleCell","getCellAnimations","type","animations","animationType","currentDirection","oppositeDirections","get","getRandomCellToBeExplored","allPossibleCells","allCellsArr","Array","from","cellPlacement","split","parseInt","Legend","Dropdown","clsx","isOpen","onChange","disabled","onClick","handleDropdownOpenStateChange","value","marginLeft","src","DropdownArrow","items","map","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","nodeBeforeEnter","GRID_HEIGHT","GRID_LENGTH","Pathfinder","updateDimensions","window","innerWidth","setState","handleMouseEnter","state","node","isNodeRegular","isStartOrEndNodeMoving","isStartNodeMoving","isFinishNodeMoving","isVisited","document","getElementById","handleMouseOut","handleMouseDown","handleMouseUp","clearPath","j","distance","Infinity","previousNode","updateCurrentAlgo","newAlgorithm","currentAlgo","startButtonText","clearGrid","startAlgorithm","classList","setTimeout","remove","fieldsAreSelected","currentSpeed","forceUpdateSpeed","gridClear","disableGrid","shortestPath","startN","GRID_WIDTH","nodesToVisit","visitedNodes","gCost","sort","nodeA","nodeB","shift","current","surroundingNodes","neighbor","distanceFromEndNode","visited","shortest","AStar","reverse","visualizePathfindingAlgorithm","GBFS","dijkstra","stack","animation","pop","DFS","generateMaze","pathAnimations","passageCellAnimations","startCell","currentFrontierCells","concat","randomFrontierCellIndex","neighborRow","neighborCol","middleNodeRow","middleNodeCol","splice","newFrontierCells","has","PrimsAlgorithm","createGridOfWalls","displayPrimsPathAnimation","visitedCells","backtrack","currentCellData","size","directionMovements","delete","nextCell","RecursiveBacktracking","displayRecursiveBacktrackingAnimation","currentSets","currentCellDirections","allCells","randomCellIndex","directionToExplore","directionObject","places","currentCellSet","neighborStringified","neighborCellSet","element","KruskalsAlgorithm","displayKruskalsAnimation","cellsInMaze","randomCell","currentPath","cellsInPath","previousDirection","nextCellStringified","cellStringified","animationObject","index","findIndex","loop","slice","WilsonsAlgorithm","displayWilsonsAlgorithm","mazeAlgorithm","isStartNodeOrEndNode","enableGrid","currentAnimations","cellAnimations","console","log","updateSpeed","speed","speedIndex","resetGrid","gridDrawn","formulateGrid","isMazeOpen","isSpeedOpen","isAlgorithmOpen","nodes","createNode","algorithms","speedValue","mazeAlgorithms","windowWidth","windowHeight","screen","ceil","this","addEventListener","removeEventListener","visualizeShortestPath","currentElement","placeholder","prevState","BrickWall","pointerEvents","marginBottom","rowIdx","nodeIdx","Component","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.aafb618f.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAABmJLR0QA/wD/AP+gvaeTAAABVElEQVR4nO3bQUrDUBRA0ae4B3FhgqvQZbcjt1AnOpE0oLTNjZ4DGf3A/+TyR4/MAAAAdLzMzPvMnDwXfQ4z83zuo9+dW5iZ48w8rqzze8eZeVpaWAtyus5Z+LT47e9vfQrWPfzg3bXbdAnfb+Rf32+RGxIjSIwgMYLECBIjSIwgMYLECBIjSIwgMYLECBIjSIwgMSaG2zEx3ANBYgSJucZMfetZdXU/M/U9EiRGkBhBYgSJESRGkBhBYgSJESRGkBhBYgSJESRGkBgz9e2Yqe+BIDGCxPhPfbv9FrkhMYLECBIjSIwgMYLECBIjSIwgMYLECBIjSIwgMYLECBJjpr4dM/U9ECRGkBj/qd9uPzP1PRIkRpAYQWIEiREkRpAYQWIEiREkRpAYQWIEiREkRpAYM/XtmKnvwVqQ481O8f8czi2sBXkdUa7hMDNvWx8CAADgyweCYnBS9zdwgQAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABmJLR0QA/wD/AP+gvaeTAAABJklEQVRoge3UMU4DMRCF4TEUqSlCgSjhOFRJrsAlECXiDFyBFsFVoICGRBQUNIT6p2CRVlHs3fHabCTe1+eN500SMxEREREREdlRwASYjjD3EJgMCdgHroE1P56BecE3xubOgZdm5idwBezlBF2y3W2NiwDTJnubi5zAVSQM4B1YFHz8osmMec0J/UoEFrlGR+tt65zwhx7BkHkNultvu89Z4JT012hTr2vQv/VfK+DEvUAz7AC4cQz7AM4TeZ7WodQfBnAGvDkG3wFHrc97Wy/6JzHoEYzVemIR7zVcC1d7+MYS3t9Gl7qtJxYZeo2/az2xRO41xmk9xnGN8VuP6XGN3Wo9BpgBT62HPwKzGrNCjVAzMyCY2bGZWQhhWWuOiIiIyH/2DfxRvrfW3thjAAAAAElFTkSuQmCC\"","import React from \"react\";\r\nimport \"./Node.css\";\r\nconst Node = (props) => {\r\n  const [isHovered, setIsHovered] = React.useState(false);\r\n  const types = [\r\n    \"Unvisited\",\r\n    \"End\",\r\n    \"Start\",\r\n    \"Wall\",\r\n    \"Path\",\r\n    \"Explored\",\r\n    \"Neighbor\",\r\n  ];\r\n\r\n  const {\r\n    col,\r\n    isFinish,\r\n    isStart,\r\n    isWall,\r\n    onMouseOut,\r\n    onMouseDown,\r\n    onMouseEnter,\r\n    onMouseUp,\r\n    row,\r\n    nodeWidth,\r\n    isShortestPathNode,\r\n    isExploredNode,\r\n    isNeighborNode,\r\n  } = props;\r\n\r\n  let extraClassName = \"\";\r\n  let hoverBackgroundColor = \"white\";\r\n  let typeIndex = 0;\r\n  if (isFinish) {\r\n    extraClassName = \"node-finish\";\r\n    hoverBackgroundColor = \"lightcoral\";\r\n    typeIndex = 1;\r\n  } else if (isStart) {\r\n    extraClassName = \"node-start\";\r\n    hoverBackgroundColor = \"lightgreen\";\r\n    typeIndex = 2;\r\n  } else if (isWall) {\r\n    extraClassName = \"node-wall\";\r\n    hoverBackgroundColor = \"#011a27\";\r\n    typeIndex = 3;\r\n  } else if (isShortestPathNode) {\r\n    extraClassName = \"node-final-path\";\r\n    hoverBackgroundColor = \"yellow\";\r\n    typeIndex = 4;\r\n  } else if (isExploredNode) {\r\n    extraClassName = \"node-visited\";\r\n    typeIndex = 5;\r\n    hoverBackgroundColor = \"#89dbff\";\r\n  } else if (isNeighborNode) {\r\n    extraClassName = \"node-neighbor\";\r\n    typeIndex = 6;\r\n    hoverBackgroundColor = \"lightsalmon\";\r\n  }\r\n\r\n  const startNodeDistance =\r\n    Math.abs(props.startNodeRow - row) + Math.abs(props.startNodeCol - col);\r\n\r\n  const endNodeDistance =\r\n    Math.abs(props.finishNodeRow - row) + Math.abs(props.finishNodeCol - col);\r\n\r\n  let cost = \"--\";\r\n  if (isExploredNode || isShortestPathNode || isNeighborNode) {\r\n    cost = props.totalCost;\r\n  }\r\n  if (isStart || isFinish) {\r\n    cost = 0;\r\n  }\r\n  return (\r\n    <>\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName} ${isHovered && \"node-inspection\"}`}\r\n        onMouseOut={() => {\r\n          onMouseOut(row, col);\r\n        }}\r\n        onMouseDown={() => {\r\n          if (!props.isWallMode) return;\r\n          onMouseDown(row, col);\r\n        }}\r\n        onMouseEnter={(e) => {\r\n          if (props.isWallMode) {\r\n            const isLeftMouseDown = e.buttons === 1;\r\n            const isShiftKeyDown = e.shiftKey;\r\n            onMouseEnter(row, col, isLeftMouseDown, isShiftKeyDown);\r\n            return;\r\n          }\r\n          if (props.gridBeingUsed) return;\r\n          setIsHovered(true);\r\n        }}\r\n        onMouseUp={(e) => {\r\n          onMouseUp(row, col);\r\n        }}\r\n        onMouseLeave={() => {\r\n          if (props.isWallMode || props.gridBeingUsed) return;\r\n          setIsHovered(false);\r\n        }}\r\n        style={{ width: `${nodeWidth}px` }}\r\n      >\r\n        {isHovered && (\r\n          <div\r\n            style={{\r\n              width: \"120px\",\r\n              height: \"140px\",\r\n              backgroundColor: hoverBackgroundColor,\r\n              zIndex: 1000,\r\n              position: \"absolute\",\r\n              bottom: \"45px\",\r\n              left: \"-55px\",\r\n              border: `1px solid ${isWall ? \"white\" : \"black\"}`,\r\n              display: \"flex\",\r\n              flexDirection: \"column\",\r\n              padding: \"6px\",\r\n              textAlign: \"left\",\r\n              fontSize: \"13px\",\r\n              justifyContent: \"space-evenly\",\r\n              color: isWall ? \"white\" : \"#011a27\",\r\n            }}\r\n          >\r\n            <div>Type: {types[typeIndex]}</div>\r\n            <div>Node Num: {props.nodeIndex}</div>\r\n            <div>Cost: {cost}</div>\r\n            <div>Row Number: {row}</div>\r\n            <div>Col Number: {col}</div>\r\n            <div>Start Distance: {startNodeDistance}</div>\r\n            <div>End Distance: {endNodeDistance}</div>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </>\r\n  );\r\n};\r\n\r\nfunction propsAreEqual(prev, next) {\r\n  const finishStateSame = prev.isFinish === next.isFinish;\r\n  const startStateSame = prev.isStart === next.isStart;\r\n  const wallStateSame = prev.isWall === next.isWall;\r\n  const sameNodeWidth = prev.nodeWidth === next.nodeWidth;\r\n  return finishStateSame && startStateSame && wallStateSame && sameNodeWidth;\r\n}\r\n\r\n// export default React.memo(Node, propsAreEqual);\r\nexport default Node;\r\n","function pathNodeInbounds(currentNode, length, height) {\r\n  const { row, col } = currentNode;\r\n  return row >= 0 && col >= 0 && row < height && col < length;\r\n}\r\n\r\nexport function getNeighbors(currentNode, grid, length, height) {\r\n  // 34, 73\r\n  let neighbors = [];\r\n  let row = currentNode.row;\r\n  let col = currentNode.col;\r\n  const north = { row: -1, col: 0 };\r\n  const east = { row: 0, col: 1 };\r\n  const south = { row: 1, col: 0 };\r\n  const west = { row: 0, col: -1 };\r\n  const northNode = { row: row + north.row, col: col + north.col };\r\n  const eastNode = { row: row + east.row, col: col + east.col };\r\n  const southNode = { row: row + south.row, col: col + south.col };\r\n  const westNode = { row: row + west.row, col: col + west.col };\r\n  if (pathNodeInbounds(westNode, length, height)) {\r\n    neighbors.push(grid[westNode.row][westNode.col]);\r\n  }\r\n  if (pathNodeInbounds(southNode, length, height)) {\r\n    neighbors.push(grid[southNode.row][southNode.col]);\r\n  }\r\n  if (pathNodeInbounds(eastNode, length, height)) {\r\n    neighbors.push(grid[eastNode.row][eastNode.col]);\r\n  }\r\n  if (pathNodeInbounds(northNode, length, height)) {\r\n    neighbors.push(grid[northNode.row][northNode.col]);\r\n  }\r\n  return neighbors;\r\n}\r\n\r\n// Generate a random number netween lowNum and highNum\r\nexport function generateRandomNumber(lowNum, highNum) {\r\n  return Math.floor(Math.random() * (highNum - lowNum + 1)) + lowNum;\r\n}\r\n\r\nexport function createNewDirectionMap() {\r\n  const directions = new Map();\r\n  directions.set(\"NORTH\", {\r\n    row: -2,\r\n    col: 0,\r\n  });\r\n  directions.set(\"SOUTH\", {\r\n    row: 2,\r\n    col: 0,\r\n  });\r\n  directions.set(\"WEST\", {\r\n    row: 0,\r\n    col: -2,\r\n  });\r\n  directions.set(\"EAST\", {\r\n    row: 0,\r\n    col: 2,\r\n  });\r\n  return directions;\r\n}\r\n\r\nexport function checkCellInBounds(cell, height, width) {\r\n  return (\r\n    cell.row >= 1 && cell.row < height && cell.col >= 1 && cell.col < width\r\n  );\r\n}\r\n\r\nexport function isStartOrEndNode(currentNode, startNode, finishNode) {\r\n  return (\r\n    (currentNode.col === startNode.col && currentNode.row === startNode.row) ||\r\n    (currentNode.col === finishNode.col && currentNode.row === finishNode.row)\r\n  );\r\n}\r\n\r\nexport function getStartCell(startNode, finishNode, height, width) {\r\n  let startCellRow = generateRandomNumber(1, height - 1);\r\n  let startCellCol = generateRandomNumber(1, width - 1);\r\n  while (\r\n    isStartOrEndNode(\r\n      { row: startCellRow, col: startCellCol },\r\n      startNode,\r\n      finishNode\r\n    ) ||\r\n    startCellRow % 2 === 0\r\n  ) {\r\n    startCellRow = generateRandomNumber(1, height - 1);\r\n    startCellCol = generateRandomNumber(1, width - 1);\r\n  }\r\n  return { row: startCellRow, col: startCellRow };\r\n}\r\n\r\nexport function getRandomDirection(currentDirections) {\r\n  const options = [];\r\n  for (const key of currentDirections.keys()) {\r\n    options.push(key);\r\n  }\r\n  const randomIndex = generateRandomNumber(0, options.length - 1);\r\n  return options[randomIndex];\r\n}\r\n","import {\r\n  checkCellInBounds,\r\n  getStartCell,\r\n  generateRandomNumber,\r\n} from \"../Functions/functions\";\r\n\r\nconst directions = [\r\n  {\r\n    row: -2,\r\n    col: 0,\r\n  },\r\n  {\r\n    row: 2,\r\n    col: 0,\r\n  },\r\n  {\r\n    row: 0,\r\n    col: 2,\r\n  },\r\n  {\r\n    row: 0,\r\n    col: -2,\r\n  },\r\n];\r\n\r\nexport function PrimsAlgorithm(grid, startNode, finishNode) {\r\n  let height = grid.length;\r\n  let width = grid[0].length;\r\n  // map representing the current state of all of the grids.\r\n  // 0: passage, 1: wall\r\n  const cellMap = [];\r\n  for (let i = 0; i < height; i++) {\r\n    const row = [];\r\n    for (let j = 0; j < width; j++) {\r\n      row.push(1);\r\n    }\r\n    cellMap.push(row);\r\n  }\r\n  let passageCellAnimations = [];\r\n  const allVisitedFrontierCells = new Set();\r\n\r\n  const startCell = getStartCell(startNode, finishNode, height, width);\r\n  cellMap[startCell.row][startCell.col] = 0;\r\n  let currentFrontierCells = getSurroundingCells(\r\n    startCell,\r\n    cellMap,\r\n    false,\r\n    allVisitedFrontierCells\r\n  );\r\n  passageCellAnimations.push({ ...startCell, frontierCell: false });\r\n  passageCellAnimations = passageCellAnimations.concat(currentFrontierCells);\r\n  while (currentFrontierCells.length > 0) {\r\n    const randomFrontierCellIndex = generateRandomNumber(\r\n      0,\r\n      currentFrontierCells.length - 1\r\n    );\r\n    const frontierCell = currentFrontierCells[randomFrontierCellIndex];\r\n\r\n    if (cellMap[frontierCell.row][frontierCell.col] === 0) {\r\n      currentFrontierCells.splice(randomFrontierCellIndex, 1);\r\n      continue;\r\n    }\r\n    // get the neighbors of the frontier cell\r\n    const neighbors = getSurroundingCells(\r\n      frontierCell,\r\n      cellMap,\r\n      true,\r\n      allVisitedFrontierCells\r\n    );\r\n\r\n    if (neighbors.length > 0) {\r\n      // cut divider between current frontier cell and neighbor\r\n      const randomNeighborIndex = generateRandomNumber(0, neighbors.length - 1);\r\n      const neighbor = neighbors[randomNeighborIndex];\r\n      const neighborRow = neighbor.row;\r\n      const neighborCol = neighbor.col;\r\n      const middleNodeRow = Math.floor((neighborRow + frontierCell.row) / 2);\r\n      const middleNodeCol = Math.floor((neighborCol + frontierCell.col) / 2);\r\n      cellMap[middleNodeRow][middleNodeCol] = 0;\r\n      passageCellAnimations.push({\r\n        row: middleNodeRow,\r\n        col: middleNodeCol,\r\n        frontierCell: false,\r\n      });\r\n    }\r\n    // remove the frontier cell from the frontier list\r\n    cellMap[frontierCell.row][frontierCell.col] = 0;\r\n    currentFrontierCells.splice(randomFrontierCellIndex, 1);\r\n    passageCellAnimations.push({ ...frontierCell, frontierCell: false });\r\n\r\n    // compute next frontierCells and add them into the list\r\n    const newFrontierCells = getSurroundingCells(\r\n      frontierCell,\r\n      cellMap,\r\n      false,\r\n      allVisitedFrontierCells\r\n    );\r\n    passageCellAnimations = passageCellAnimations.concat(newFrontierCells);\r\n    for (const cell of newFrontierCells) {\r\n      if (allVisitedFrontierCells.has(`${cell.row}:${cell.col}`)) continue;\r\n      passageCellAnimations.push(cell);\r\n    }\r\n    currentFrontierCells = currentFrontierCells.concat(newFrontierCells);\r\n  }\r\n  return passageCellAnimations;\r\n}\r\n\r\nfunction getSurroundingCells(\r\n  currentCell,\r\n  cellMap,\r\n  isPath,\r\n  allVisitedFrontierCells\r\n) {\r\n  const frontierCells = [];\r\n  const currentRow = currentCell.row;\r\n  const currentCol = currentCell.col;\r\n  const height = cellMap.length;\r\n  const width = cellMap[0].length;\r\n  const numericalIsPath = isPath ? 0 : 1;\r\n  for (const direction of directions) {\r\n    const currentFrontierCell = {\r\n      row: currentRow + direction.row,\r\n      col: currentCol + direction.col,\r\n    };\r\n    const cellIsInbounds = checkCellInBounds(\r\n      currentFrontierCell,\r\n      height,\r\n      width\r\n    );\r\n    if (\r\n      cellIsInbounds &&\r\n      cellMap[currentFrontierCell.row][currentFrontierCell.col] ===\r\n        numericalIsPath\r\n    ) {\r\n      frontierCells.push({ ...currentFrontierCell, frontierCell: true });\r\n      if (!isPath) {\r\n        allVisitedFrontierCells.add(\r\n          `${currentFrontierCell.row}:${currentFrontierCell.col}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n  return frontierCells;\r\n}\r\n","import {\r\n  checkCellInBounds,\r\n  generateRandomNumber,\r\n  createNewDirectionMap,\r\n  getRandomDirection,\r\n} from \"../Functions/functions\";\r\n\r\nexport function KruskalsAlgorithm(grid) {\r\n  let height = grid.length;\r\n  let width = grid[0].length;\r\n  // map representing the current state of all of the grids.\r\n  // 0: passage, 1: wall\r\n  const cellMap = [];\r\n  for (let i = 0; i < height; i++) {\r\n    const row = [];\r\n    for (let j = 0; j < width; j++) {\r\n      row.push(1);\r\n    }\r\n    cellMap.push(row);\r\n  }\r\n  const passageCellAnimations = [];\r\n\r\n  // This will map a string (node) to its set that it belongs to\r\n  const currentSets = new Map();\r\n  // This will map a cell to all of the directions it has yet to explore\r\n  const currentCellDirections = new Map();\r\n  // Array that contains all of the cells\r\n  const allCells = [];\r\n  // Add each node to its own set\r\n  for (let i = 0; i < height; i++) {\r\n    if (i % 2 === 0) continue;\r\n    for (let j = 0; j < width; j++) {\r\n      if (j % 2 === 0) continue;\r\n      const cell = `${i}:${j}`;\r\n      const set = new Set();\r\n      set.add(cell);\r\n      currentSets.set(cell, set);\r\n      currentCellDirections.set(cell, createNewDirectionMap());\r\n      allCells.push(cell);\r\n    }\r\n  }\r\n  while (allCells.length !== 0) {\r\n    const randomCellIndex = generateRandomNumber(0, allCells.length - 1);\r\n    const currentCell = allCells[randomCellIndex];\r\n    // Get a random direction to explore\r\n    const currentDirections = currentCellDirections.get(currentCell);\r\n    const directionToExplore = getRandomDirection(currentDirections);\r\n    const directionObject = currentDirections.get(directionToExplore);\r\n    currentDirections.delete(directionToExplore);\r\n    if (currentDirections.size === 0) {\r\n      allCells.splice(randomCellIndex, 1);\r\n    }\r\n    const places = currentCell.split(\":\");\r\n    const currentRow = parseInt(places[0]);\r\n    const currentCol = parseInt(places[1]);\r\n    const neighbor = {\r\n      row: parseInt(places[0]) + directionObject.row,\r\n      col: parseInt(places[1]) + directionObject.col,\r\n    };\r\n    // if the neighboring cell is out of bounds, then continue\r\n    if (!checkCellInBounds(neighbor, height, width)) continue;\r\n    const currentCellSet = currentSets.get(currentCell);\r\n    // if the cells are already in the same set, then continue\r\n    const neighborStringified = `${neighbor.row}:${neighbor.col}`;\r\n    if (currentCellSet.has(neighborStringified)) {\r\n      continue;\r\n    }\r\n    // if they are in different sets, then merge the sets together\r\n    const neighborCellSet = currentSets.get(neighborStringified);\r\n    const mergedSet = mergeTwoSets(currentCellSet, neighborCellSet);\r\n    for (const element of currentCellSet) {\r\n      currentSets.set(element, mergedSet);\r\n    }\r\n    for (const element of neighborCellSet) {\r\n      currentSets.set(element, mergedSet);\r\n    }\r\n    const middleNodeRow = Math.floor((neighbor.row + parseInt(places[0])) / 2);\r\n    const middleNodeCol = Math.floor((neighbor.col + parseInt(places[1])) / 2);\r\n    if (cellMap[middleNodeRow][middleNodeCol] !== 0) {\r\n      passageCellAnimations.push({ row: middleNodeRow, col: middleNodeCol });\r\n    }\r\n    if (cellMap[parseInt(places[0])][parseInt(places[1])] !== 0) {\r\n      passageCellAnimations.push({\r\n        row: parseInt(places[0]),\r\n        col: parseInt(places[1]),\r\n      });\r\n    }\r\n    if (cellMap[neighbor.row][neighbor.col] !== 0) {\r\n      passageCellAnimations.push({ row: neighbor.row, col: neighbor.col });\r\n    }\r\n    cellMap[middleNodeRow][middleNodeCol] = 0;\r\n    cellMap[parseInt(places[0])][parseInt(places[1])] = 0;\r\n    cellMap[neighbor.row][neighbor.col] = 0;\r\n  }\r\n  return passageCellAnimations;\r\n}\r\n\r\nfunction mergeTwoSets(set1, set2) {\r\n  const mergedSet = new Set();\r\n  for (const el of set1) {\r\n    mergedSet.add(el);\r\n  }\r\n  for (const el of set2) {\r\n    mergedSet.add(el);\r\n  }\r\n  return mergedSet;\r\n}\r\n","import React from \"react\";\r\nimport {\r\n  generateRandomNumber,\r\n  checkCellInBounds,\r\n  createNewDirectionMap,\r\n} from \"../Functions/functions\";\r\n\r\nexport const MAZE_TYPE = \"MAZE_TYPE\";\r\nexport const EXPLORE_TYPE = \"EXPLORE_TYPE\";\r\nexport const WALL_TYPE = \"WALL_TYPE\";\r\n\r\nexport function WilsonsAlgorithm(grid) {\r\n  let height = grid.length;\r\n  let width = grid[0].length;\r\n  const directions = createNewDirectionMap();\r\n  // map representing the current state of all of the grids.\r\n  // 0: passage, 1: wall\r\n  const cellMap = [];\r\n  const allPossibleCells = new Set();\r\n  for (let i = 0; i < height; i++) {\r\n    const row = [];\r\n    for (let j = 0; j < width; j++) {\r\n      row.push(1);\r\n      if (i % 2 !== 0 && j % 2 !== 0) {\r\n        allPossibleCells.add(`${i}:${j}`);\r\n      }\r\n    }\r\n    cellMap.push(row);\r\n  }\r\n  const animations = [];\r\n  const cellsInMaze = new Set();\r\n  cellsInMaze.add(`${1}:${1}`);\r\n  cellsInMaze.add(`${1}:${2}`);\r\n  cellsInMaze.add(`${1}:${3}`);\r\n  allPossibleCells.delete(`${1}:${1}`);\r\n  allPossibleCells.delete(`${1}:${2}`);\r\n  allPossibleCells.delete(`${1}:${3}`);\r\n\r\n  const beginningAnimationsArr = [\r\n    { row: 1, col: 1 },\r\n    { row: 1, col: 2 },\r\n    { row: 1, col: 3 },\r\n  ];\r\n  animations.push(getCellAnimations(beginningAnimationsArr, MAZE_TYPE));\r\n\r\n  while (allPossibleCells.size !== 0) {\r\n    const randomCell = getRandomCellToBeExplored(allPossibleCells);\r\n    animations.push(getCellAnimations([randomCell], EXPLORE_TYPE));\r\n    const currentPath = [];\r\n    const cellsInPath = new Set();\r\n\r\n    currentPath.push(randomCell);\r\n    cellsInPath.add(`${randomCell.row}:${randomCell.col}`);\r\n    let previousDirection = null;\r\n\r\n    while (true) {\r\n      const currentCell = currentPath[currentPath.length - 1];\r\n      const currentDirection = getRandomDirection(\r\n        previousDirection,\r\n        currentCell,\r\n        directions,\r\n        height,\r\n        width\r\n      );\r\n      const directionObject = directions.get(currentDirection);\r\n      const nextCell = {\r\n        row: currentCell.row + directionObject.row,\r\n        col: currentCell.col + directionObject.col,\r\n      };\r\n      const nextCellStringified = `${nextCell.row}:${nextCell.col}`;\r\n      // Check to see if the next cell is in the maze or is currently part of the path\r\n      if (cellsInMaze.has(nextCellStringified)) {\r\n        // remove the cells in the current path from the cells that are not in the maze\r\n        for (const cell of currentPath) {\r\n          const cellStringified = `${cell.row}:${cell.col}`;\r\n          allPossibleCells.delete(cellStringified);\r\n          cellsInMaze.add(cellStringified);\r\n        }\r\n        // animate\r\n        const path = getFullPath(currentPath, false);\r\n        path.push(getMiddleCell(currentCell, nextCell));\r\n        const animationObject = getCellAnimations(path, MAZE_TYPE);\r\n        animations.push(animationObject);\r\n        break;\r\n      } else if (cellsInPath.has(nextCellStringified)) {\r\n        const middleCell = getMiddleCell(currentCell, nextCell);\r\n        animations.push(getCellAnimations([middleCell], EXPLORE_TYPE));\r\n        const index = currentPath.findIndex(\r\n          (el) => el.row === nextCell.row && el.col === nextCell.col\r\n        );\r\n        const loop = currentPath.slice(index + 1);\r\n        const path = getFullPath([currentPath[index], ...loop], true);\r\n        const animationObject = getCellAnimations(\r\n          [middleCell, ...path],\r\n          WALL_TYPE\r\n        );\r\n        animations.push(animationObject);\r\n        if (index === 0) {\r\n          animations.push(getCellAnimations([currentPath[0]], WALL_TYPE));\r\n          break;\r\n        }\r\n        currentPath.splice(index + 1);\r\n        for (const cell of loop) {\r\n          const cellStringified = `${cell.row}:${cell.col}`;\r\n          cellsInPath.delete(cellStringified);\r\n        }\r\n        previousDirection =\r\n          index === 1 ? null : getPreviousDirection(currentPath);\r\n      } else {\r\n        // cell is neither in the maze or in the current path\r\n        currentPath.push(nextCell);\r\n        cellsInPath.add(`${nextCell.row}:${nextCell.col}`);\r\n        const middleCell = getMiddleCell(currentCell, nextCell);\r\n        const animationObject = getCellAnimations(\r\n          [middleCell, nextCell],\r\n          EXPLORE_TYPE\r\n        );\r\n        animations.push(animationObject);\r\n        previousDirection = currentDirection;\r\n      }\r\n    }\r\n  }\r\n  return animations;\r\n}\r\n\r\nfunction getPreviousDirection(cellArr) {\r\n  const cell1 = cellArr[cellArr.length - 1];\r\n  const cell2 = cellArr[cellArr.length - 2];\r\n  if (cell1.row < cell2.row) {\r\n    return \"NORTH\";\r\n  } else if (cell1.row > cell2.row) {\r\n    return \"SOUTH\";\r\n  } else if (cell1.col < cell2.col) {\r\n    return \"WEST\";\r\n  } else {\r\n    return \"EAST\";\r\n  }\r\n}\r\n\r\nfunction getFullPath(cellArray, isLoopPath) {\r\n  const path = [];\r\n  for (let i = 0; i < cellArray.length - 1; i++) {\r\n    const currentCell = cellArray[i];\r\n    const nextCell = cellArray[i + 1];\r\n    const middleCell = getMiddleCell(currentCell, nextCell);\r\n    path.push(middleCell);\r\n    if (i === 0 && isLoopPath) continue;\r\n    path.push(currentCell);\r\n  }\r\n  path.push(cellArray[cellArray.length - 1]);\r\n  return path;\r\n}\r\n\r\nfunction getCellAnimations(cellArray, type) {\r\n  const animationObj = {\r\n    animations: cellArray,\r\n    animationType: type,\r\n  };\r\n  return animationObj;\r\n}\r\n\r\nfunction getMiddleCell(cell1, cell2) {\r\n  const middleNodeRow = Math.floor((cell1.row + cell2.row) / 2);\r\n  const middleNodeCol = Math.floor((cell1.col + cell2.col) / 2);\r\n  return {\r\n    row: middleNodeRow,\r\n    col: middleNodeCol,\r\n  };\r\n}\r\n\r\n/*\r\n  The direction returned will give a valid neighbor and also will not be the same direction that the\r\n  path has previously come from\r\n*/\r\nfunction getRandomDirection(\r\n  currentDirection,\r\n  currentCell,\r\n  directions,\r\n  height,\r\n  width\r\n) {\r\n  const options = [\"NORTH\", \"SOUTH\", \"WEST\", \"EAST\"];\r\n  const oppositeDirections = new Map();\r\n  oppositeDirections.set(\"NORTH\", \"SOUTH\");\r\n  oppositeDirections.set(\"SOUTH\", \"NORTH\");\r\n  oppositeDirections.set(\"EAST\", \"WEST\");\r\n  oppositeDirections.set(\"WEST\", \"EAST\");\r\n  let direction = options[generateRandomNumber(0, options.length - 1)];\r\n  while (\r\n    direction === oppositeDirections.get(currentDirection) ||\r\n    !checkCellInBounds(\r\n      {\r\n        row: currentCell.row + directions.get(direction).row,\r\n        col: currentCell.col + directions.get(direction).col,\r\n      },\r\n      height,\r\n      width\r\n    )\r\n  ) {\r\n    direction = options[generateRandomNumber(0, options.length - 1)];\r\n  }\r\n  return direction;\r\n}\r\n\r\nfunction getRandomCellToBeExplored(allPossibleCells) {\r\n  const allCellsArr = Array.from(allPossibleCells);\r\n  let randomIndex = generateRandomNumber(0, allCellsArr.length - 1);\r\n  let cellPlacement = allCellsArr[randomIndex].split(\":\");\r\n  let cellRow = parseInt(cellPlacement[0]);\r\n  let cellCol = parseInt(cellPlacement[1]);\r\n  return { row: cellRow, col: cellCol };\r\n}\r\n","import React from \"react\";\r\nimport \"./Legend.css\";\r\n\r\nconst Legend = () => {\r\n  return (\r\n    <div className=\"container\">\r\n      <div className=\"container-and-label\">\r\n        <div className=\"fake-node fake-node-start-color\"></div>\r\n        <div>Start Node</div>\r\n      </div>\r\n      <div className=\"container-and-label\">\r\n        <div className=\"fake-node fake-node-end-color\"></div>\r\n        <div>End Node</div>\r\n      </div>\r\n      <div className=\"container-and-label\">\r\n        <div className=\"fake-node fake-node-wall-color\"></div>\r\n        <div>Wall Node</div>\r\n      </div>\r\n      <div className=\"container-and-label\">\r\n        <div className=\"fake-node\"></div>\r\n        <div>Unvisted Node</div>\r\n      </div>\r\n      <div className=\"container-and-label\">\r\n        <div className=\"fake-node fake-node-explored-first-color\"></div>\r\n        <div>Explored Node</div>\r\n      </div>\r\n      <div className=\"container-and-label\">\r\n        <div className=\"fake-node fake-node-neighbor\"></div>\r\n        <div>Neighbor Node</div>\r\n      </div>\r\n      <div className=\"container-and-label last-container\">\r\n        <div className=\"fake-node fake-node-shortest-path-color\"></div>\r\n        <div>Path Found Node</div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Legend;\r\n","import React from \"react\";\r\nimport clsx from \"clsx\";\r\nimport \"./Dropdown.css\";\r\nimport DropdownArrow from \"../../../assets/drop-down-down.png\";\r\n\r\nconst Dropdown = (props) => {\r\n  return (\r\n    <div className={\"drop-down-container\"}>\r\n      <button\r\n        className={clsx(\r\n          \"drop-down-button\",\r\n          props.gridBeingUsed && \"drop-down-button-disabled\",\r\n          props.isOpen && \"drop-down-button-selected\"\r\n        )}\r\n        id={props.id}\r\n        onChange={props.onChange}\r\n        disabled={props.gridBeingUsed ? true : false}\r\n        onClick={() => props.handleDropdownOpenStateChange(props.type)}\r\n      >\r\n        {props.value}\r\n        <img\r\n          style={{ width: \"16px\", marginLeft: \"14px\" }}\r\n          src={DropdownArrow}\r\n        ></img>\r\n      </button>\r\n      {props.isOpen && (\r\n        <div className=\"drop-down-elements-container\">\r\n          {props.items.map((el) => (\r\n            <div key={el} value={el} className=\"drop-down-element\">\r\n              <div\r\n                className=\"drop-down-element-text\"\r\n                onClick={() => props.onChange(el)}\r\n              >\r\n                {el}\r\n              </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Dropdown;\r\n","import React, { Component } from \"react\";\r\nimport { BiSearchAlt2 } from \"react-icons/bi\";\r\nimport BrickWall from \"../assets/brick-wall.png\";\r\nimport Node from \"./Node/Node\";\r\nimport { dijkstra } from \"../Algos/Dijkstra\";\r\nimport { AStar } from \"../Algos/AStar\";\r\nimport { DFS } from \"../Algos/DepthFirstSearch\";\r\nimport { GBFS } from \"../Algos/GreedyBestFirstSearch\";\r\nimport { PrimsAlgorithm } from \"../Maze/PrimsAlgorithm\";\r\nimport { RecursiveBacktracking } from \"../Maze/RecursiveBacktracking\";\r\nimport { KruskalsAlgorithm } from \"../Maze/KruskalsAlgorithm\";\r\nimport {\r\n  WilsonsAlgorithm,\r\n  WALL_TYPE,\r\n  MAZE_TYPE,\r\n  EXPLORE_TYPE,\r\n} from \"../Maze/WilsonsAlgorithm\";\r\nimport Legend from \"./Components/Legend/Legend\";\r\nimport Dropdown from \"./Components/Dropdown/Dropdown\";\r\nimport clsx from \"clsx\";\r\nimport \"./Pathfinder.css\";\r\n\r\n/*\r\n  DISCLAIMER: \r\n    In the following application, I had to modify the state without using setState at times. This is because when the user is\r\n    dragging to make walls or running an algorithm, the component (the grid) would need to be rerendered so many times that it caused the application\r\n    to lag. The only way to avoid this lag was to change the state without causing the whole component to rerender. I know this is not the best practice\r\n    but I tried to use state correctly wherever I could.\r\n*/\r\n\r\nlet START_NODE_ROW = 10;\r\nlet START_NODE_COL = 10;\r\nlet FINISH_NODE_ROW = 10;\r\nlet FINISH_NODE_COL = 45;\r\n\r\n// 0 = regular node, 1 = wall, 2 = explored, 3 = shortest-path\r\nlet nodeBeforeEnter = -1;\r\n\r\nlet GRID_HEIGHT = 20;\r\nlet GRID_LENGTH = 50;\r\nexport default class Pathfinder extends Component {\r\n  // last algo: 0 = A*, 1 = Greedy, 2= Dijkstra, 3= DFS\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      gridClear: true,\r\n      isStartNodeMoving: false,\r\n      isFinishNodeMoving: false,\r\n      algorithms: [\r\n        \"A* Algorithm\",\r\n        \"Greedy Best-First Search\",\r\n        \"Dijkstra's Algorithm\",\r\n        \"Depth First Search\",\r\n      ],\r\n      currentAlgo: \"Algorithms\",\r\n      speed: [\"Slow\", \"Normal\", \"Fast\"],\r\n      currentSpeed: \"Speed\",\r\n      speedValue: [100, 6, 4],\r\n      speedIndex: 1,\r\n      mazeAlgorithms: [\r\n        \"Prim's Algorithm\",\r\n        \"Wilson's Algorithm\",\r\n        \"Kruskal's Algorithm\",\r\n        \"Recursive Backtracking\",\r\n      ],\r\n      startButtonText: \"Choose Algorithm\",\r\n      gridBeingUsed: false,\r\n      nodeWidth: 25,\r\n      isAlgorithmOpen: false,\r\n      isMazeOpen: false,\r\n      isSpeedOpen: false,\r\n      isWallMode: true,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    let windowWidth = window.innerWidth;\r\n    let windowHeight = window.screen.height;\r\n    GRID_HEIGHT = Math.ceil((windowHeight - 250) / 25);\r\n    GRID_LENGTH = Math.ceil((windowWidth - 50) / 25);\r\n    if (GRID_HEIGHT % 2 === 0) GRID_HEIGHT++;\r\n    if (GRID_LENGTH % 2 === 0) GRID_LENGTH--;\r\n    START_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n    FINISH_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n    START_NODE_COL = Math.floor(GRID_LENGTH / 4);\r\n    FINISH_NODE_COL = Math.floor(GRID_LENGTH * (4 / 5));\r\n    const gridDrawn = this.formulateGrid();\r\n    this.setState({\r\n      grid: gridDrawn,\r\n      nodeWidth: 25,\r\n    });\r\n    window.addEventListener(\"resize\", this.updateDimensions);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.removeEventListener(\"resize\", this.updateDimensions);\r\n  }\r\n\r\n  updateDimensions = () => {\r\n    const GRID_WIDTH_PX = window.innerWidth - 50;\r\n    const nodeWidth = GRID_WIDTH_PX / GRID_LENGTH;\r\n    this.setState({\r\n      nodeWidth: Math.floor(nodeWidth),\r\n    });\r\n  };\r\n\r\n  // if mouse enters the boundary of any node\r\n  handleMouseEnter = (row, col, isLeftMouseDown, isShiftKeyDown) => {\r\n    if (this.state.gridBeingUsed || !this.state.isWallMode) return;\r\n    const node = this.state.grid[row][col];\r\n    // use this to take the state of the node back to what it was\r\n    nodeBeforeEnter = -1;\r\n    if (node.isWall) {\r\n      nodeBeforeEnter = 1;\r\n    } else if (node.isExploredNode) {\r\n      nodeBeforeEnter = 2;\r\n    } else if (node.isShortestPathNode) {\r\n      nodeBeforeEnter = 3;\r\n    } else if (node.isNeighborNode) {\r\n      nodeBeforeEnter = 4;\r\n    }\r\n    // if dragging to make walls\r\n    const isNodeRegular = !node.isFinish && !node.isStart;\r\n    const isStartOrEndNodeMoving =\r\n      this.state.isStartNodeMoving || this.state.isFinishNodeMoving;\r\n    if (isNodeRegular && !isStartOrEndNodeMoving && isLeftMouseDown) {\r\n      node.isWall = true;\r\n      node.isVisited = false;\r\n      node.isShortestPathNode = false;\r\n      node.isExploredNode = false;\r\n      node.isNeighborNode = false;\r\n      document.getElementById(`node-${row}-${col}`).className =\r\n        \"node node-wall\";\r\n    } else if (isNodeRegular && !isStartOrEndNodeMoving && isShiftKeyDown) {\r\n      node.isWall = false;\r\n      node.isVisited = false;\r\n      node.isShortestPathNode = false;\r\n      node.isExploredNode = false;\r\n      node.isNeighborNode = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n    } else if (this.state.isStartNodeMoving && !node.isFinish) {\r\n      // if the start node is being dragged, set the nodes in the array accordingly and then\r\n      // set the row and column of where the start node is\r\n      node.isStart = true;\r\n      node.isWall = false;\r\n      node.isVisited = false;\r\n      node.isShortestPathNode = false;\r\n      node.isExploredNode = false;\r\n      node.isNeighborNode = false;\r\n      document.getElementById(`node-${row}-${col}`).className =\r\n        \"node node-start\";\r\n      START_NODE_ROW = row;\r\n      START_NODE_COL = col;\r\n    } else if (this.state.isFinishNodeMoving && !node.isStart) {\r\n      // if the finish node is moving, do the same thing as described above\r\n      node.isFinish = true;\r\n      node.isWall = false;\r\n      node.isVisited = false;\r\n      node.isShortestPathNode = false;\r\n      node.isExploredNode = false;\r\n      node.isNeighborNode = false;\r\n      document.getElementById(`node-${row}-${col}`).className =\r\n        \"node node-finish\";\r\n      FINISH_NODE_ROW = row;\r\n      FINISH_NODE_COL = col;\r\n    }\r\n  };\r\n\r\n  // when the mouse leaves a certain node\r\n  handleMouseOut = (row, col) => {\r\n    let currentNode = this.state.grid[row][col];\r\n    // if the start node is moving\r\n    if (this.state.isStartNodeMoving && !currentNode.isFinish) {\r\n      // set this node back into a regular node\r\n      currentNode.isStart = false;\r\n      currentNode.isFinish = false;\r\n      currentNode.isWall = false;\r\n      currentNode.isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n    } else if (this.state.isFinishNodeMoving && !currentNode.isStart) {\r\n      // if finish node has moved out of this node, put node back into regular node\r\n      currentNode.isStart = false;\r\n      currentNode.isFinish = false;\r\n      currentNode.isWall = false;\r\n      currentNode.isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n    }\r\n    if (this.state.isStartNodeMoving || this.state.isFinishNodeMoving) {\r\n      if (nodeBeforeEnter === 1) {\r\n        // if the node was orinally a wall before the start/end node moved into it, set it\r\n        // back to a wall\r\n        currentNode.isWall = true;\r\n        currentNode.isVisited = false;\r\n        document.getElementById(`node-${row}-${col}`).className =\r\n          \"node node-wall\";\r\n      } else if (nodeBeforeEnter === 2) {\r\n        currentNode.isWall = false;\r\n        currentNode.isVisited = true;\r\n        currentNode.isExploredNode = true;\r\n        document.getElementById(`node-${row}-${col}`).className =\r\n          \"node node-visited\";\r\n      } else if (nodeBeforeEnter === 3) {\r\n        currentNode.isWall = false;\r\n        currentNode.isVisited = true;\r\n        currentNode.isExploredNode = false;\r\n        currentNode.isShortestPathNode = true;\r\n        document.getElementById(`node-${row}-${col}`).className =\r\n          \"node node-final-path\";\r\n      } else if (nodeBeforeEnter === 4) {\r\n        currentNode.isWall = false;\r\n        currentNode.isVisited = true;\r\n        currentNode.isExploredNode = false;\r\n        currentNode.isShortestPathNode = false;\r\n        currentNode.isNeighborNode = true;\r\n        document.getElementById(`node-${row}-${col}`).className =\r\n          \"node node-neighbor\";\r\n      }\r\n    }\r\n  };\r\n\r\n  handleMouseDown = (row, col) => {\r\n    if (this.state.gridBeingUsed || !this.state.isWallMode) return;\r\n    let currentNode = this.state.grid[row][col];\r\n    if (!currentNode.isFinish && !currentNode.isStart && !currentNode.isWall) {\r\n      currentNode.isVisited = false;\r\n      currentNode.isWall = true;\r\n      document.getElementById(`node-${row}-${col}`).className =\r\n        \"node node-wall\";\r\n    } else if (\r\n      !currentNode.isFinish &&\r\n      !currentNode.isStart &&\r\n      currentNode.isWall\r\n    ) {\r\n      // turn the node back into a regular node and indicate that the mouse is being pressed\r\n      currentNode.isVisited = false;\r\n      currentNode.isWall = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n    } else if (currentNode.isStart) {\r\n      // if the user is pressed on the start node, indicate that the start node is moving\r\n      this.setState({\r\n        isStartNodeMoving: true,\r\n      });\r\n    } else if (currentNode.isFinish) {\r\n      // if the user is pressed on the finish  node, indicate that the finish node is moving\r\n      this.setState({\r\n        isFinishNodeMoving: true,\r\n      });\r\n    }\r\n  };\r\n\r\n  handleMouseUp = (row, col) => {\r\n    // if the mouse is released\r\n    let currentNode = this.state.grid[row][col];\r\n    // the start and finish node are not being moved\r\n    if (this.state.isStartNodeMoving || this.state.isFinishNodeMoving) {\r\n      this.setState({\r\n        isStartNodeMoving: false,\r\n        isFinishNodeMoving: false,\r\n      });\r\n    }\r\n\r\n    // if the start or end node is moving, update accordingly\r\n    if (this.state.isStartNodeMoving) {\r\n      START_NODE_ROW = row;\r\n      START_NODE_COL = col;\r\n    } else if (this.state.isFinishNodeMoving) {\r\n      FINISH_NODE_ROW = row;\r\n      FINISH_NODE_COL = col;\r\n    }\r\n\r\n    // if the finish node is on top of the start node\r\n    if (\r\n      START_NODE_COL === FINISH_NODE_COL &&\r\n      START_NODE_ROW === FINISH_NODE_ROW\r\n    ) {\r\n      // reset the nodes to their original positions\r\n      currentNode.isFinish = false;\r\n      currentNode.isVisited = false;\r\n      currentNode.isStart = false;\r\n      currentNode.isWall = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n\r\n      START_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n      FINISH_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n      START_NODE_COL = Math.floor(GRID_LENGTH / 4);\r\n      FINISH_NODE_COL = Math.floor(GRID_LENGTH * (4 / 5));\r\n\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isWall = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isVisited = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isFinish = false;\r\n      this.state.grid[START_NODE_ROW][\r\n        START_NODE_COL\r\n      ].isShortestPathNode = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isExploredNode = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isNeighborNode = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isStart = true;\r\n      document.getElementById(\r\n        `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n      ).className = \"node node-start\";\r\n\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isWall = false;\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isVisited = false;\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = true;\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isStart = false;\r\n      this.state.grid[START_NODE_ROW][\r\n        START_NODE_COL\r\n      ].isShortestPathNode = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isExploredNode = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isNeighborNode = false;\r\n      document.getElementById(\r\n        `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n      ).className = \"node node-finish\";\r\n    }\r\n  };\r\n\r\n  visualizePathfindingAlgorithm(nodes, shortestPath) {\r\n    for (let i = 0; i <= nodes.length; i++) {\r\n      if (i === nodes.length) {\r\n        // if the other elements are done updating, show the shortest path\r\n        setTimeout(() => {\r\n          this.visualizeShortestPath(shortestPath);\r\n        }, this.state.speedValue[this.state.speedIndex] * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const currentElement = nodes[i];\r\n          const { node, type } = currentElement;\r\n          if (!node.isStart && !node.isFinish) {\r\n            if (type === \"VISITED\") {\r\n              this.state.grid[node.row][node.col].isExploredNode = true;\r\n              this.state.grid[node.row][node.col].isNeighborNode = false;\r\n\r\n              document.getElementById(\r\n                `node-${node.row}-${node.col}`\r\n              ).className = `node node-visited disabledNode`;\r\n            } else {\r\n              this.state.grid[node.row][node.col].isExploredNode = false;\r\n              this.state.grid[node.row][node.col].isNeighborNode = true;\r\n              document.getElementById(\r\n                `node-${node.row}-${node.col}`\r\n              ).className = `node node-neighbor disabledNode`;\r\n            }\r\n          }\r\n        }, this.state.speedValue[this.state.speedIndex] * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  // visualize the path found\r\n  displayAlgo(nodes, shortestPath) {\r\n    for (let i = 0; i <= nodes.length; i++) {\r\n      if (i === nodes.length) {\r\n        // if the other elements are done updating, show the shortest path\r\n        setTimeout(() => {\r\n          this.visualizeShortestPath(shortestPath);\r\n        }, this.state.speedValue[this.state.speedIndex] * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          if (!node.isStart && !node.isFinish) {\r\n            this.state.grid[node.row][node.col].isExploredNode = true;\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-visited disabledNode\";\r\n          }\r\n        }, this.state.speedValue[this.state.speedIndex] * i);\r\n        const node = nodes[i];\r\n      }\r\n    }\r\n  }\r\n\r\n  // show the shortest path\r\n  visualizeShortestPath(shortestPath) {\r\n    this.setState({\r\n      gridClear: false,\r\n    });\r\n    for (let j = 0; j <= shortestPath.length; j++) {\r\n      if (j === shortestPath.length) {\r\n        setTimeout(() => {\r\n          this.enableGrid();\r\n          this.setState({\r\n            gridBeingUsed: false,\r\n          });\r\n        }, (this.state.speedValue[this.state.speedIndex] + 4) * j);\r\n      } else {\r\n        setTimeout(() => {\r\n          const node = shortestPath[j];\r\n          if (!node.isStart && !node.isFinish) {\r\n            this.state.grid[node.row][node.col].isExploredNode = false;\r\n            this.state.grid[node.row][node.col].isShortestPathNode = true;\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-final-path disabledNode\";\r\n          }\r\n        }, (this.state.speedValue[this.state.speedIndex] + 4) * j);\r\n      }\r\n    }\r\n  }\r\n\r\n  // clear the grid of all path nodes\r\n  clearPath = () => {\r\n    nodeBeforeEnter = -1;\r\n    for (let i = 0; i < GRID_HEIGHT; i++) {\r\n      for (let j = 0; j < GRID_LENGTH; j++) {\r\n        if (i === START_NODE_ROW && j === START_NODE_COL) {\r\n          document.getElementById(`node-${i}-${j}`).className =\r\n            \"node node-start\";\r\n          this.state.grid[i][j].distance = Infinity;\r\n          this.state.grid[i][j].isVisited = false;\r\n          this.state.grid[i][j].isWall = false;\r\n          this.state.grid[i][j].previousNode = null;\r\n        } else if (i === FINISH_NODE_ROW && j === FINISH_NODE_COL) {\r\n          document.getElementById(`node-${i}-${j}`).className =\r\n            \"node node-finish\";\r\n          this.state.grid[i][j].distance = Infinity;\r\n          this.state.grid[i][j].isVisited = false;\r\n          this.state.grid[i][j].isWall = false;\r\n          this.state.grid[i][j].previousNode = null;\r\n        } else if (\r\n          this.state.grid[i][j].isVisited &&\r\n          !this.state.grid[i][j].isFinish\r\n        ) {\r\n          document.getElementById(`node-${i}-${j}`).className = \"node\";\r\n          this.state.grid[i][j].distance = Infinity;\r\n          this.state.grid[i][j].isVisited = false;\r\n          this.state.grid[i][j].isWall = false;\r\n          this.state.grid[i][j].previousNode = null;\r\n        }\r\n        this.state.grid[i][j].isExploredNode = false;\r\n        this.state.grid[i][j].isShortestPathNode = false;\r\n        this.state.grid[i][j].isNeighborNode = false;\r\n      }\r\n    }\r\n  };\r\n\r\n  updateCurrentAlgo = (newAlgorithm) => {\r\n    this.handleDropdownOpenStateChange(\"\");\r\n    this.setState({\r\n      currentAlgo: newAlgorithm,\r\n      startButtonText: \"Visualize\",\r\n    });\r\n  };\r\n\r\n  // clear the grid of all wall and path nodes\r\n  clearGrid = () => {\r\n    if (!this.state.isStartNodeMoving && !this.state.isFinishNodeMoving) {\r\n      nodeBeforeEnter = -1;\r\n      for (let i = 0; i < GRID_HEIGHT; i++) {\r\n        for (let j = 0; j < GRID_LENGTH; j++) {\r\n          this.state.grid[i][j].distance = Infinity;\r\n          this.state.grid[i][j].isVisited = false;\r\n          this.state.grid[i][j].isWall = false;\r\n          this.state.grid[i][j].previousNode = null;\r\n          this.state.grid[i][j].isExploredNode = false;\r\n          this.state.grid[i][j].isShortestPathNode = false;\r\n          this.state.grid[i][j].isNeighborNode = false;\r\n          this.state.grid[i][j].totalCost = 0;\r\n          if (i === START_NODE_ROW && j === START_NODE_COL) {\r\n            document.getElementById(`node-${i}-${j}`).className =\r\n              \"node node-start\";\r\n            this.state.grid[i][j].isStart = true;\r\n          } else if (i === FINISH_NODE_ROW && j === FINISH_NODE_COL) {\r\n            document.getElementById(`node-${i}-${j}`).className =\r\n              \"node node-finish\";\r\n            this.state.grid[i][j].isFinish = true;\r\n          } else {\r\n            document.getElementById(`node-${i}-${j}`).className = \"node\";\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  startAlgorithm = () => {\r\n    if (this.state.gridBeingUsed) return;\r\n    this.handleDropdownOpenStateChange(\"\");\r\n    if (this.state.currentAlgo === \"Algorithms\") {\r\n      document\r\n        .getElementById(\"pathfinding-algorithm-selection\")\r\n        .classList.add(\"drop-down-button-selected\");\r\n      setTimeout(() => {\r\n        document\r\n          .getElementById(\"pathfinding-algorithm-selection\")\r\n          .classList.remove(\"drop-down-button-selected\");\r\n      }, 450);\r\n      return;\r\n    }\r\n    const fieldsAreSelected = !(\r\n      this.state.currentSpeed === \"Speed\" &&\r\n      this.state.currentAlgo !== \"Algorithms\"\r\n    );\r\n    const boardIsBeingUsed =\r\n      this.state.currentAlgo !== \"Algorithms\" &&\r\n      !this.state.isStartNodeMoving &&\r\n      !this.state.isFinishNodeMoving;\r\n\r\n    if (boardIsBeingUsed) {\r\n      if (!fieldsAreSelected) {\r\n        this.forceUpdateSpeed();\r\n      }\r\n      this.setState({\r\n        gridBeingUsed: true,\r\n      });\r\n    }\r\n    const { currentAlgo } = this.state;\r\n    if (this.state.isStartNodeMoving || this.state.isFinishNodeMoving) return;\r\n    if (!this.state.gridClear) {\r\n      this.clearPath();\r\n    }\r\n    this.disableGrid();\r\n    let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n    let path;\r\n    if (currentAlgo === \"A* Algorithm\") {\r\n      path = AStar(\r\n        this.state.grid,\r\n        startNode,\r\n        GRID_LENGTH,\r\n        GRID_HEIGHT,\r\n        FINISH_NODE_ROW,\r\n        FINISH_NODE_COL\r\n      );\r\n      let shortestPath = path.shortest.reverse();\r\n      this.visualizePathfindingAlgorithm(path.visited, shortestPath);\r\n    } else if (currentAlgo === \"Greedy Best-First Search\") {\r\n      path = GBFS(\r\n        this.state.grid,\r\n        startNode,\r\n        GRID_LENGTH,\r\n        GRID_HEIGHT,\r\n        FINISH_NODE_ROW,\r\n        FINISH_NODE_COL\r\n      );\r\n      let shortestPath = path.shortest.reverse();\r\n      this.visualizePathfindingAlgorithm(path.visited, shortestPath);\r\n    } else if (currentAlgo === \"Dijkstra's Algorithm\") {\r\n      path = dijkstra(this.state.grid, startNode, GRID_LENGTH, GRID_HEIGHT);\r\n      let shortestPath = path.shortest.reverse();\r\n      this.visualizePathfindingAlgorithm(path.visited, shortestPath);\r\n    } else if (currentAlgo === \"Depth First Search\") {\r\n      path = DFS(this.state.grid, startNode, GRID_LENGTH, GRID_HEIGHT);\r\n      this.visualizePathfindingAlgorithm(\r\n        path.visited,\r\n        path.shortest === null ? [] : path.shortest\r\n      );\r\n    }\r\n  };\r\n\r\n  // generate a maze to be displayed\r\n  generateMaze = (type) => {\r\n    this.handleDropdownOpenStateChange(\"\");\r\n    if (this.state.isStartNodeMoving || this.state.isFinishNodeMoving) return;\r\n    this.clearGrid();\r\n    this.disableGrid();\r\n    this.setState({\r\n      gridBeingUsed: true,\r\n    });\r\n    if (type === \"Prim's Algorithm\") {\r\n      const pathAnimations = PrimsAlgorithm(\r\n        this.state.grid,\r\n        { row: START_NODE_ROW, col: START_NODE_COL },\r\n        { row: FINISH_NODE_ROW, col: FINISH_NODE_COL }\r\n      );\r\n      this.createGridOfWalls(pathAnimations, this.displayPrimsPathAnimation);\r\n    } else if (type === \"Recursive Backtracking\") {\r\n      const pathAnimations = RecursiveBacktracking(\r\n        this.state.grid,\r\n        { row: START_NODE_ROW, col: START_NODE_COL },\r\n        { row: FINISH_NODE_ROW, col: FINISH_NODE_COL }\r\n      );\r\n      this.createGridOfWalls(\r\n        pathAnimations,\r\n        this.displayRecursiveBacktrackingAnimation\r\n      );\r\n    } else if (type === \"Kruskal's Algorithm\") {\r\n      const pathAnimations = KruskalsAlgorithm(this.state.grid);\r\n      this.createGridOfWalls(pathAnimations, this.displayKruskalsAnimation);\r\n    } else if (type === \"Wilson's Algorithm\") {\r\n      const animations = WilsonsAlgorithm(this.state.grid);\r\n      this.createGridOfWalls(animations, this.displayWilsonsAlgorithm);\r\n    }\r\n  };\r\n\r\n  createGridOfWalls = (pathAnimations, mazeAlgorithm) => {\r\n    // create a grid of walls\r\n    for (let i = 0; i < GRID_HEIGHT; i++) {\r\n      for (let j = 0; j <= GRID_LENGTH; j++) {\r\n        if (i === GRID_HEIGHT - 1 && j === GRID_LENGTH) {\r\n          setTimeout(() => {\r\n            mazeAlgorithm(pathAnimations);\r\n          }, (i * GRID_HEIGHT + j) * 10 + 500);\r\n        } else {\r\n          if (j === GRID_LENGTH) continue;\r\n          setTimeout(() => {\r\n            if (this.isStartNodeOrEndNode(i, j)) return;\r\n            this.state.grid[i][j].isWall = true;\r\n            this.state.grid[i][j].isVisited = false;\r\n            this.state.grid[i][j].isStart = false;\r\n            this.state.grid[i][j].isExploredNode = false;\r\n            this.state.grid[i][j].isShortestPathNode = false;\r\n            this.state.grid[i][j].isNeighborNode = false;\r\n            this.state.grid[i][j].isFinish = false;\r\n            document.getElementById(`node-${i}-${j}`).className =\r\n              \"node node-wall\";\r\n          }, (i * GRID_HEIGHT + j) * 10);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  displayWilsonsAlgorithm = (animations) => {\r\n    for (let i = 0; i <= animations.length; i++) {\r\n      if (i === animations.length) {\r\n        setTimeout(() => {\r\n          this.enableGrid();\r\n          this.setState({\r\n            gridBeingUsed: false,\r\n          });\r\n        }, 5 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const currentAnimations = animations[i];\r\n          const cellAnimations = currentAnimations.animations;\r\n          const type = currentAnimations.animationType;\r\n          for (const cell of cellAnimations) {\r\n            const { row, col } = cell;\r\n            if (this.isStartNodeOrEndNode(row, col)) continue;\r\n            if (type === WALL_TYPE) {\r\n              document.getElementById(\r\n                `node-${row}-${col}`\r\n              ).className = `node node-wall`;\r\n              this.state.grid[row][col].isWall = true;\r\n            } else if (type === EXPLORE_TYPE) {\r\n              document.getElementById(\r\n                `node-${row}-${col}`\r\n              ).className = `node node-frontier`;\r\n              this.state.grid[row][col].isWall = false;\r\n            } else if (type === MAZE_TYPE) {\r\n              document.getElementById(`node-${row}-${col}`).className = `node`;\r\n              this.state.grid[row][col].isWall = false;\r\n            } else {\r\n              console.log(\"this should not happen\");\r\n            }\r\n          }\r\n        }, 5 * i);\r\n      }\r\n    }\r\n  };\r\n\r\n  displayKruskalsAnimation = (pathAnimations) => {\r\n    for (let i = 0; i <= pathAnimations.length; i++) {\r\n      if (i === pathAnimations.length) {\r\n        setTimeout(() => {\r\n          this.enableGrid();\r\n          this.setState({\r\n            gridBeingUsed: false,\r\n          });\r\n        }, 15 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const currentCell = pathAnimations[i];\r\n          const { row, col } = currentCell;\r\n          if (this.isStartNodeOrEndNode(row, col)) return;\r\n          this.state.grid[row][col].isWall = false;\r\n          document.getElementById(`node-${row}-${col}`).className = `node`;\r\n        }, 15 * i);\r\n      }\r\n    }\r\n  };\r\n\r\n  displayRecursiveBacktrackingAnimation = (pathAnimations) => {\r\n    for (let i = 0; i <= pathAnimations.length; i++) {\r\n      if (i === pathAnimations.length) {\r\n        setTimeout(() => {\r\n          for (const cell of pathAnimations) {\r\n            const { row, col, backtrack } = cell;\r\n            if (this.isStartNodeOrEndNode(row, col)) continue;\r\n            if (!backtrack) continue;\r\n            document.getElementById(`node-${row}-${col}`).className = `node`;\r\n          }\r\n          this.enableGrid();\r\n          this.setState({\r\n            gridBeingUsed: false,\r\n          });\r\n        }, 15 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const currentCell = pathAnimations[i];\r\n          const { row, col, backtrack } = currentCell;\r\n          if (this.isStartNodeOrEndNode(row, col)) return;\r\n          this.state.grid[row][col].isWall = false;\r\n          document.getElementById(`node-${row}-${col}`).className = `node ${\r\n            backtrack ? \"node-backtrack\" : \"\"\r\n          }`;\r\n        }, 15 * i);\r\n      }\r\n    }\r\n  };\r\n\r\n  displayPrimsPathAnimation = (pathAnimations) => {\r\n    for (let i = 0; i <= pathAnimations.length; i++) {\r\n      if (i === pathAnimations.length) {\r\n        setTimeout(() => {\r\n          this.enableGrid();\r\n          this.setState({\r\n            gridBeingUsed: false,\r\n          });\r\n        }, 12 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          const currentCell = pathAnimations[i];\r\n          const { row, col, frontierCell } = currentCell;\r\n          if (this.isStartNodeOrEndNode(row, col)) return;\r\n          this.state.grid[row][col].isWall = false;\r\n          document.getElementById(`node-${row}-${col}`).className = `node ${\r\n            frontierCell && \"node-frontier\"\r\n          }`;\r\n        }, 12 * i);\r\n      }\r\n    }\r\n  };\r\n\r\n  isStartNodeOrEndNode = (row, col) => {\r\n    return (\r\n      (row === START_NODE_ROW && col === START_NODE_COL) ||\r\n      (row === FINISH_NODE_ROW && col === FINISH_NODE_COL)\r\n    );\r\n  };\r\n\r\n  updateSpeed = (speed) => {\r\n    this.handleDropdownOpenStateChange(\"\");\r\n    if (speed === \"Slow\") {\r\n      this.setState({\r\n        speedIndex: 0,\r\n        currentSpeed: \"Slow\",\r\n      });\r\n    } else if (speed === \"Normal\") {\r\n      this.setState({\r\n        speedIndex: 1,\r\n        currentSpeed: \"Normal\",\r\n      });\r\n    } else if (speed === \"Fast\") {\r\n      this.setState({\r\n        speedIndex: 2,\r\n        currentSpeed: \"Fast\",\r\n      });\r\n    }\r\n  };\r\n\r\n  // If the user does not choose a speed, choose normal for them\r\n  forceUpdateSpeed = () => {\r\n    this.setState({\r\n      speedIndex: 1,\r\n      currentSpeed: \"Normal\",\r\n    });\r\n  };\r\n\r\n  // Set the grid to how it was when game first started\r\n  resetGrid = () => {\r\n    if (!this.state.isStartNodeMoving && !this.state.isFinishNodeMoving) {\r\n      this.handleDropdownOpenStateChange(\"\");\r\n      this.clearGrid();\r\n      START_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n      FINISH_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n      START_NODE_COL = Math.floor(GRID_LENGTH / 4);\r\n      FINISH_NODE_COL = Math.floor(GRID_LENGTH * (4 / 5));\r\n      const gridDrawn = this.formulateGrid();\r\n      this.setState({\r\n        grid: gridDrawn,\r\n        speedIndex: 1,\r\n        currentAlgo: \"Algorithms\",\r\n        currentSpeed: \"Speed\",\r\n        startButtonText: \"Choose Algorithm\",\r\n        isWallMode: true,\r\n      });\r\n    }\r\n  };\r\n\r\n  handleDropdownOpenStateChange = (type) => {\r\n    if (type === \"ALGORITHMS\") {\r\n      this.setState({\r\n        isMazeOpen: false,\r\n        isSpeedOpen: false,\r\n        isAlgorithmOpen: !this.state.isAlgorithmOpen,\r\n      });\r\n    } else if (type === \"GENERATE_WALLS\") {\r\n      this.setState({\r\n        isAlgorithmOpen: false,\r\n        isSpeedOpen: false,\r\n        isMazeOpen: !this.state.isMazeOpen,\r\n      });\r\n    } else if (type === \"SPEED\") {\r\n      this.setState({\r\n        isAlgorithmOpen: false,\r\n        isMazeOpen: false,\r\n        isSpeedOpen: !this.state.isSpeedOpen,\r\n      });\r\n    } else {\r\n      this.setState({\r\n        isAlgorithmOpen: false,\r\n        isMazeOpen: false,\r\n        isSpeedOpen: false,\r\n      });\r\n    }\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"overall-container\">\r\n        <div className=\"menu-container\">\r\n          <div className=\"button-container\">\r\n            <div\r\n              className={clsx(\r\n                \"header\",\r\n                this.state.gridBeingUsed && \"header-disabled\"\r\n              )}\r\n              onClick={this.state.gridBeingUsed ? null : this.resetGrid}\r\n            >\r\n              Pathfinding Visualized\r\n            </div>\r\n            <div className=\"buttons\">\r\n              <Dropdown\r\n                gridBeingUsed={this.state.gridBeingUsed}\r\n                placeholder=\"Algorithms\"\r\n                id=\"pathfinding-algorithm-selection\"\r\n                onChange={this.updateCurrentAlgo}\r\n                value={this.state.currentAlgo}\r\n                items={this.state.algorithms}\r\n                handleDropdownOpenStateChange={\r\n                  this.handleDropdownOpenStateChange\r\n                }\r\n                type=\"ALGORITHMS\"\r\n                isOpen={this.state.isAlgorithmOpen}\r\n              />\r\n              <Dropdown\r\n                gridBeingUsed={this.state.gridBeingUsed}\r\n                placeholder=\"Generate Maze\"\r\n                id=\"maze-algorithm-selection\"\r\n                onChange={this.generateMaze}\r\n                value={\"Generate Maze\"}\r\n                items={this.state.mazeAlgorithms}\r\n                handleDropdownOpenStateChange={\r\n                  this.handleDropdownOpenStateChange\r\n                }\r\n                type=\"GENERATE_WALLS\"\r\n                isOpen={this.state.isMazeOpen}\r\n              />\r\n              <Dropdown\r\n                gridBeingUsed={this.state.gridBeingUsed}\r\n                placeholder=\"Speed\"\r\n                id=\"speed-selection\"\r\n                onChange={this.updateSpeed}\r\n                value={this.state.currentSpeed}\r\n                items={this.state.speed}\r\n                handleDropdownOpenStateChange={\r\n                  this.handleDropdownOpenStateChange\r\n                }\r\n                type=\"SPEED\"\r\n                isOpen={this.state.isSpeedOpen}\r\n              />\r\n              <button\r\n                className={clsx(\r\n                  \"button\",\r\n                  \"button-start\",\r\n                  this.state.gridBeingUsed && \"button-start-disabled\"\r\n                )}\r\n                id=\"start-algorithm\"\r\n                onClick={() => this.startAlgorithm()}\r\n                disabled={this.state.gridBeingUsed ? true : false}\r\n              >\r\n                {this.state.startButtonText}\r\n              </button>\r\n              <button\r\n                id=\"clear-grid\"\r\n                className={clsx(\r\n                  \"button\",\r\n                  this.state.gridBeingUsed && \"button-clear-disabled\",\r\n                  !this.state.gridBeingUsed && \"button-clear\"\r\n                )}\r\n                onClick={this.clearGrid}\r\n                disabled={this.state.gridBeingUsed ? true : false}\r\n              >\r\n                Clear Grid\r\n              </button>\r\n              <button\r\n                id=\"reset-button\"\r\n                className={clsx(\r\n                  \"button\",\r\n                  this.state.gridBeingUsed && \"button-clear-disabled\",\r\n                  !this.state.gridBeingUsed && \"button-clear\"\r\n                )}\r\n                onClick={this.resetGrid}\r\n                disabled={this.state.gridBeingUsed}\r\n              >\r\n                Reset\r\n              </button>\r\n            </div>\r\n          </div>\r\n          <button\r\n            className={\"inspection-button\"}\r\n            disabled={\r\n              this.state.gridBeingUsed ||\r\n              this.state.isStartNodeMoving ||\r\n              this.state.isFinishNodeMoving\r\n            }\r\n            onClick={() => {\r\n              this.setState((prevState) => {\r\n                return {\r\n                  ...prevState,\r\n                  isWallMode: !prevState.isWallMode,\r\n                };\r\n              });\r\n            }}\r\n          >\r\n            {this.state.isWallMode ? (\r\n              <img style={{ width: \"22px\", height: \"22px\" }} src={BrickWall} />\r\n            ) : (\r\n              <BiSearchAlt2 style={{ width: \"22px\", height: \"22px\" }} />\r\n            )}\r\n          </button>\r\n        </div>\r\n        <div\r\n          className=\"grid-and-legend\"\r\n          style={{ pointerEvents: this.state.gridBeingUsed ? \"none\" : \"\" }}\r\n        >\r\n          <div\r\n            className=\"legend-container\"\r\n            onClick={() => this.handleDropdownOpenStateChange(\"\")}\r\n          >\r\n            <Legend />\r\n          </div>\r\n          <div\r\n            id=\"gridNodes\"\r\n            className=\"grid\"\r\n            onClick={() => this.handleDropdownOpenStateChange(\"\")}\r\n          >\r\n            <div\r\n              style={{\r\n                textAlign: \"center\",\r\n                marginLeft: \"-10px\",\r\n                marginBottom: \"10px\",\r\n              }}\r\n            >\r\n              {this.state.grid.map((row, rowIdx) => {\r\n                return (\r\n                  <div key={rowIdx}>\r\n                    {row.map((node, nodeIdx) => {\r\n                      const {\r\n                        row,\r\n                        col,\r\n                        isFinish,\r\n                        isStart,\r\n                        isWall,\r\n                        isShortestPathNode,\r\n                        isExploredNode,\r\n                        totalCost,\r\n                        isNeighborNode,\r\n                      } = node;\r\n                      return (\r\n                        <Node\r\n                          key={nodeIdx}\r\n                          col={col}\r\n                          isFinish={isFinish}\r\n                          isStart={isStart}\r\n                          isWall={isWall}\r\n                          onMouseDown={(row, col) =>\r\n                            this.handleMouseDown(row, col)\r\n                          }\r\n                          onMouseEnter={(\r\n                            row,\r\n                            col,\r\n                            isLeftMouseDown,\r\n                            isShiftKeyDown\r\n                          ) =>\r\n                            this.handleMouseEnter(\r\n                              row,\r\n                              col,\r\n                              isLeftMouseDown,\r\n                              isShiftKeyDown\r\n                            )\r\n                          }\r\n                          onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                          onMouseOut={(row, col) =>\r\n                            this.handleMouseOut(row, col)\r\n                          }\r\n                          row={row}\r\n                          nodeWidth={this.state.nodeWidth}\r\n                          isWallMode={this.state.isWallMode}\r\n                          nodeIndex={rowIdx * GRID_LENGTH + nodeIdx}\r\n                          isShortestPathNode={isShortestPathNode}\r\n                          isExploredNode={isExploredNode}\r\n                          isNeighborNode={isNeighborNode}\r\n                          startNodeRow={START_NODE_ROW}\r\n                          startNodeCol={START_NODE_COL}\r\n                          finishNodeRow={FINISH_NODE_ROW}\r\n                          finishNodeCol={FINISH_NODE_COL}\r\n                          totalCost={totalCost}\r\n                        />\r\n                      );\r\n                    })}\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  disableGrid() {\r\n    for (let i = 0; i < GRID_HEIGHT; i++) {\r\n      for (let j = 0; j < GRID_LENGTH; j++) {\r\n        document.getElementById(`node-${i}-${j}`).classList.add(\"disabledNode\");\r\n      }\r\n    }\r\n  }\r\n\r\n  enableGrid() {\r\n    for (let i = 0; i < GRID_HEIGHT; i++) {\r\n      for (let j = 0; j < GRID_LENGTH; j++) {\r\n        document\r\n          .getElementById(`node-${i}-${j}`)\r\n          .classList.remove(\"disabledNode\");\r\n      }\r\n    }\r\n  }\r\n\r\n  // generate the beginning grid\r\n  formulateGrid = () => {\r\n    // draw a grid onto the screen\r\n    const nodes = [];\r\n    for (let i = 0; i < GRID_HEIGHT; i++) {\r\n      const row = [];\r\n      for (let j = 0; j < GRID_LENGTH; j++) {\r\n        row.push(this.createNode(j, i));\r\n      }\r\n      nodes.push(row);\r\n    }\r\n    return nodes;\r\n  };\r\n\r\n  // create a node\r\n  createNode = (col, row) => {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      isShortestPathNode: false,\r\n      isExploredNode: false,\r\n      totalCost: 0,\r\n      isNeighborNode: false,\r\n    };\r\n  };\r\n}\r\n","import { getNeighbors } from \"../Functions/functions\";\r\n\r\n// A* algo\r\nexport function AStar(\r\n  grid,\r\n  startN,\r\n  GRID_LENGTH,\r\n  GRID_WIDTH,\r\n  FINISH_NODE_ROW,\r\n  FINISH_NODE_COL\r\n) {\r\n  let nodesToVisit = [];\r\n  let visitedNodes = [];\r\n  let shortestPath = [];\r\n  let startNode = grid[startN.row][startN.col];\r\n\r\n  // push the start node into the array to be explored\r\n  startNode.distance = 0;\r\n  startNode.gCost = 0;\r\n  startNode.isVisited = true;\r\n  nodesToVisit.push(startNode);\r\n\r\n  // while array containing the nodes to be explored is not empty\r\n  while (nodesToVisit.length !== 0) {\r\n    // sort the array\r\n    nodesToVisit.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    // take the first element out of the array\r\n    let currentNode = nodesToVisit.shift();\r\n    // check if the current node is the finish node\r\n    if (currentNode.isFinish) {\r\n      let current = currentNode;\r\n      // if it is, get the shortest path\r\n      while (current !== null) {\r\n        shortestPath.push(current);\r\n        current = current.previousNode;\r\n      }\r\n      // end the loop\r\n      break;\r\n    }\r\n    // if the currenNode is a wall, dont do anything\r\n    if (currentNode.isWall) continue;\r\n\r\n    // get the nodes surrounding the currentNode\r\n    let surroundingNodes = getNeighbors(\r\n      currentNode,\r\n      grid,\r\n      GRID_LENGTH,\r\n      GRID_WIDTH\r\n    );\r\n\r\n    // for every neighbor\r\n    for (let i = 0; i < surroundingNodes.length; i++) {\r\n      // if the node is not a wall and is not the start node\r\n      if (!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n        let neighbor = surroundingNodes[i];\r\n        // if the neighbor has not already been visited\r\n        if (neighbor.isVisited) continue;\r\n        // get the distance between current node and end node (H cost)\r\n        let distanceFromEndX = Math.abs(FINISH_NODE_ROW - neighbor.row);\r\n        let distanceFromEndY = Math.abs(FINISH_NODE_COL - neighbor.col);\r\n        let distanceFromEndNode = (distanceFromEndX + distanceFromEndY) * 10;\r\n\r\n        // set the previous node equal to the current node\r\n        neighbor.previousNode = currentNode;\r\n\r\n        // get the g cost, determined by a nodes distance from the start node\r\n        neighbor.gCost = currentNode.gCost + 10;\r\n\r\n        // A* is calculated by adding Gcost with Hcost\r\n        neighbor.distance = neighbor.gCost + distanceFromEndNode;\r\n        neighbor.totalCost = neighbor.gCost + distanceFromEndNode;\r\n        neighbor.isVisited = true;\r\n        nodesToVisit.push(neighbor);\r\n        visitedNodes.push({ node: neighbor, type: \"NEIGHBOR\" });\r\n      }\r\n    }\r\n    // push currentNode into the visited array\r\n    visitedNodes.push({ node: currentNode, type: \"VISITED\" });\r\n  }\r\n  // return the path and the shortest path\r\n  let path = {\r\n    visited: visitedNodes,\r\n    shortest: shortestPath,\r\n  };\r\n  return path;\r\n}\r\n","import { getNeighbors } from \"../Functions/functions\";\r\n\r\n// Greedier version of A*\r\nexport function GBFS(\r\n  grid,\r\n  startN,\r\n  GRID_LENGTH,\r\n  GRID_WIDTH,\r\n  FINISH_NODE_ROW,\r\n  FINISH_NODE_COL\r\n) {\r\n  let nodesToVisit = [];\r\n  let visitedNodes = [];\r\n  let shortestPath = [];\r\n  let startNode = grid[startN.row][startN.col];\r\n\r\n  startNode.isVisited = true;\r\n  nodesToVisit.push(startNode);\r\n\r\n  while (nodesToVisit.length !== 0) {\r\n    nodesToVisit.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    let currentNode = nodesToVisit.shift();\r\n    if (currentNode.isFinish) {\r\n      shortestPath.push(currentNode);\r\n      let current = currentNode.previousNode;\r\n      while (current !== null) {\r\n        shortestPath.push(current);\r\n        current = current.previousNode;\r\n      }\r\n      break;\r\n    }\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    let surroundingNodes = getNeighbors(\r\n      currentNode,\r\n      grid,\r\n      GRID_LENGTH,\r\n      GRID_WIDTH\r\n    );\r\n    for (let i = 0; i < surroundingNodes.length; i++) {\r\n      if (!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n        let neighbor = surroundingNodes[i];\r\n        if (!neighbor.isVisited) {\r\n          // get the distance between current node and end node (H cost)\r\n          let distanceFromEndX = Math.abs(FINISH_NODE_ROW - neighbor.row) * 10;\r\n          let distanceFromEndY = Math.abs(FINISH_NODE_COL - neighbor.col) * 10;\r\n          let distanceFromEndNode = distanceFromEndX + distanceFromEndY;\r\n\r\n          // Greedy best first search only takes into account distance from end node\r\n          // when calculating cost. Thus f(n) = h(n)\r\n          neighbor.previousNode = currentNode;\r\n          neighbor.distance = distanceFromEndNode;\r\n          neighbor.totalCost = distanceFromEndNode;\r\n          neighbor.isVisited = true;\r\n          nodesToVisit.push(neighbor);\r\n          visitedNodes.push({ node: neighbor, type: \"NEIGHBOR\" });\r\n        }\r\n      }\r\n    }\r\n    visitedNodes.push({ node: currentNode, type: \"VISITED\" });\r\n  }\r\n  let path = {\r\n    visited: visitedNodes,\r\n    shortest: shortestPath,\r\n  };\r\n  return path;\r\n}\r\n","import { getNeighbors } from \"../Functions/functions\";\r\n\r\nexport function dijkstra(grid, startN, GRID_LENGTH, GRID_WIDTH) {\r\n  let nodesToVisit = [];\r\n  let visitedNodes = [];\r\n  let shortestPath = [];\r\n\r\n  // set the start node in the grid\r\n  let startNode = grid[startN.row][startN.col];\r\n\r\n  // push the first node into the array of nodes to explore\r\n  startNode.distance = 0;\r\n  startNode.isVisited = true;\r\n  nodesToVisit.push(startNode);\r\n\r\n  // while there are more nodes to explore\r\n  while (nodesToVisit.length !== 0) {\r\n    // sort\r\n    nodesToVisit.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    // take the first node out\r\n    let currentNode = nodesToVisit.shift();\r\n    // if its the finish node, return\r\n    if (currentNode.isFinish) {\r\n      shortestPath.push(currentNode);\r\n      let current = currentNode.previousNode;\r\n      while (current !== null) {\r\n        shortestPath.push(current);\r\n        current = current.previousNode;\r\n      }\r\n      break;\r\n    }\r\n    if (currentNode.isWall) continue;\r\n    let surroundingNodes = getNeighbors(\r\n      currentNode,\r\n      grid,\r\n      GRID_LENGTH,\r\n      GRID_WIDTH\r\n    );\r\n\r\n    for (let i = 0; i < surroundingNodes.length; i++) {\r\n      if (!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n        let neighbor = surroundingNodes[i];\r\n        if (!neighbor.isVisited) {\r\n          // set previous node accordingly and push all of neighbors into the array to be visited\r\n          neighbor.previousNode = currentNode;\r\n          neighbor.distance = currentNode.distance + 10;\r\n          neighbor.totalCost = currentNode.distance + 10;\r\n          neighbor.isVisited = true;\r\n          nodesToVisit.push(neighbor);\r\n          visitedNodes.push({ node: neighbor, type: \"NEIGHBOR\" });\r\n        }\r\n      }\r\n    }\r\n    visitedNodes.push({ node: currentNode, type: \"VISITED\" });\r\n  }\r\n  // return the path and shortest path calculated\r\n  let path = {\r\n    visited: visitedNodes,\r\n    shortest: shortestPath,\r\n  };\r\n  return path;\r\n}\r\n","import { getNeighbors } from \"../Functions/functions\";\r\n\r\n// depth first search\r\nexport function DFS(grid, startNode, length, height) {\r\n  // push the first node into the array containing the nodes to be explored\r\n  let stack = [];\r\n  stack.push(startNode);\r\n  startNode.isVisited = true;\r\n  let animation = [];\r\n  //[1, 2, 3, 4]\r\n  while (stack.length !== 0) {\r\n    const currentNode = stack.pop();\r\n    currentNode.isVisited = true;\r\n\r\n    // terminate\r\n    if (currentNode.isFinish) {\r\n      const shortestPath = [];\r\n      let current = currentNode.previousNode;\r\n      while (current !== null) {\r\n        shortestPath.push(current);\r\n        current = current.previousNode;\r\n      }\r\n      return {\r\n        visited: animation,\r\n        shortest: shortestPath.reverse(),\r\n      };\r\n    }\r\n    if (!currentNode.isStart) {\r\n      animation.push({ node: currentNode, type: \"VISITED\" });\r\n    }\r\n    // [W, S, E, N]\r\n    const neighbors = getNeighbors(currentNode, grid, length, height);\r\n    for (const neighbor of neighbors) {\r\n      if (neighbor.isVisited || neighbor.isWall) continue;\r\n      stack.push(neighbor);\r\n      neighbor.previousNode = currentNode;\r\n      neighbor.totalCost = \"N/A\";\r\n      animation.push({ node: neighbor, type: \"NEIGHBOR\" });\r\n    }\r\n  }\r\n  return {\r\n    visited: animation,\r\n    shortest: null,\r\n  };\r\n}\r\n","import {\r\n  checkCellInBounds,\r\n  createNewDirectionMap,\r\n  getStartCell,\r\n  getRandomDirection,\r\n} from \"../Functions/functions\";\r\n\r\nexport function RecursiveBacktracking(grid, startNode, finishNode) {\r\n  let height = grid.length;\r\n  let width = grid[0].length;\r\n  // map representing the current state of all of the grids.\r\n  // 0: passage, 1: wall\r\n  const cellMap = [];\r\n  for (let i = 0; i < height; i++) {\r\n    const row = [];\r\n    for (let j = 0; j < width; j++) {\r\n      row.push(1);\r\n    }\r\n    cellMap.push(row);\r\n  }\r\n  const passageCellAnimations = [];\r\n  const visitedCells = new Set();\r\n\r\n  const startCell = getStartCell(startNode, finishNode, height, width);\r\n  cellMap[startCell.row][startCell.col] = 0;\r\n  visitedCells.add(`${startCell.row}:${startCell.col}`);\r\n  const stack = [];\r\n  stack.push({\r\n    cell: startCell,\r\n    directions: createNewDirectionMap(),\r\n    backtrack: false,\r\n  });\r\n  while (stack.length > 0) {\r\n    const currentCellData = stack[stack.length - 1];\r\n    const cell = currentCellData.cell;\r\n    cellMap[cell.row][cell.col] = 0;\r\n    const currentDirections = currentCellData.directions;\r\n    if (currentDirections.size === 0) {\r\n      passageCellAnimations.push({ ...cell, backtrack: true });\r\n      stack.pop();\r\n      if (stack.length !== 0) {\r\n        const nextCell = stack[stack.length - 1].cell;\r\n        const middleNodeRow = Math.floor((nextCell.row + cell.row) / 2);\r\n        const middleNodeCol = Math.floor((nextCell.col + cell.col) / 2);\r\n        passageCellAnimations.push({\r\n          row: middleNodeRow,\r\n          col: middleNodeCol,\r\n          backtrack: true,\r\n        });\r\n      }\r\n      continue;\r\n    }\r\n    passageCellAnimations.push({ ...cell, backtrack: false });\r\n    const direction = getRandomDirection(currentDirections);\r\n    const directionMovements = currentDirections.get(direction);\r\n    currentDirections.delete(direction);\r\n    // we need to remove the cell in the middle as well\r\n    const neighbor = {\r\n      row: cell.row + directionMovements.row,\r\n      col: cell.col + directionMovements.col,\r\n    };\r\n    const shouldSkipCell =\r\n      !checkCellInBounds(neighbor, height, width) ||\r\n      cellMap[neighbor.row][neighbor.col] === 0 ||\r\n      visitedCells.has(`${neighbor.row}:${neighbor.col}`);\r\n    if (shouldSkipCell) {\r\n      continue;\r\n    }\r\n    // make cell inbetween a passage as well\r\n    const middleNodeRow = Math.floor((neighbor.row + cell.row) / 2);\r\n    const middleNodeCol = Math.floor((neighbor.col + cell.col) / 2);\r\n    cellMap[middleNodeRow][middleNodeCol] = 0;\r\n    passageCellAnimations.push({\r\n      row: middleNodeRow,\r\n      col: middleNodeCol,\r\n      backtrack: false,\r\n    });\r\n    stack.push({\r\n      cell: neighbor,\r\n      directions: createNewDirectionMap(),\r\n    });\r\n    visitedCells.add(`${neighbor.row}:${neighbor.col}`);\r\n  }\r\n  return passageCellAnimations;\r\n}\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport Pathfinder from \"./PathfinderVisualization/Pathfinder\";\r\n\r\n/*\r\n  Big thanks to Clement Mihailescu, who inspired me to do this project!\r\n\r\n  His youtube channel can be found here: https://www.youtube.com/channel/UCaO6VoaYJv4kS-TQO_M-N_g\r\n*/\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"app\">\r\n      <Pathfinder />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}