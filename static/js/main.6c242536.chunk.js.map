{"version":3,"sources":["PathfinderVisualization/Node/Node.js","Functions/functions.js","Algos/DepthFirstSearch.js","Maze/RandomMaze.js","Maze/VerticalWalls.js","Maze/HorizontalWalls.js","PathfinderVisualization/Pathfinder.js","Algos/GreedyBestFirstSearch.js","Algos/BreadthFirstSearch.js","Algos/AStar.js","Algos/Dijkstra.js","App.js","serviceWorker.js","index.js"],"names":["Pathfinder","props","state","this","col","isFinish","isStart","isWall","onMouseOut","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","Component","getNeighbors","currentNode","grid","GRID_LENGTH","GRID_WIDTH","neighbors","x","y","push","generateSideWalls","wallNodes","StartNode","FinishNode","width","height","node","generateRandomNumber","lowNum","highNum","Math","floor","random","DFS","startN","nodesToVisit","helperDFS","nodesVisited","length","visited","shortest","i","neighbor","isVisited","previousNode","recursiveResult","undefined","pop","RandomMaze","j","VerticalWalls","HorizontalWalls","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","mouseIsPressed","nodeBeforeEnter","GRID_HEIGHT","handleMouseEnter","startNodeMove","finishNodeMove","document","getElementById","startAlgorithm","handleMouseOut","handleMouseDown","setState","handleMouseUp","visualizeDepthFirstSearch","animate","gridClear","clearPath","lastAlgo","disableGrid","startNode","path","displayAlgoNoPath","displayAlgo","visualizeGreedyBestFirstSearch","visitedNodes","shortestPath","sort","nodeA","nodeB","distance","shift","current","surroundingNodes","distanceFromEndNode","abs","GBFS","reverse","visualizeBreadthFirstSearch","BFS","visualizeAStar","gCost","distanceFromStartX","distanceFromStartY","aStar","visualizeDijkstra","dijkstra","Infinity","updateCurrentAlgo","event","currentAlgo","target","value","startButtonPhrase","clearGrid","currentSpeed","forceUpdateSpeed","gridBeingUsed","algo","generateMaze","a","type","walls","displayMaze","nodes","setTimeout","enableGrid","updateSpeed","speed","speedIndex","resetGrid","gridDrawn","formulateGrid","mazeLabel","createNode","beingUsed","windowWidth","window","screen","windowHeight","ceil","addEventListener","removeEventListener","speedValue","visualizeShortestPath","onChange","disabled","selected","hidden","algorithms","map","key","mazeAlgorithms","maze","onClick","rowIdx","nodeIdx","classList","add","remove","App","Boolean","location","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.6c242536.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\nexport default class Pathfinder extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseOut,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n\r\n    let extraClassName = \"\";\r\n    if (isFinish) {\r\n      extraClassName = \"node-finish\";\r\n    } else if (isStart) {\r\n      extraClassName = \"node-start\";\r\n    } else if (isWall) {\r\n      extraClassName = \"node-wall\";\r\n    }\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseOut={() => onMouseOut(row, col)}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp(row, col)}\r\n      />\r\n    );\r\n  }\r\n}\r\n","const NORTH = -1;\r\nconst EAST = 1;\r\nconst SOUTH = 1;\r\nconst WEST = -1;\r\n\r\nexport function getNeighbors(currentNode, grid, GRID_LENGTH, GRID_WIDTH) {\r\n  let neighbors = [];\r\n  let x = currentNode.row;\r\n  let y = currentNode.col;\r\n\r\n  if (x > 0 && y > 0 && y < GRID_LENGTH - 1 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if (x === 0 && y === 0) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if (x === 0 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + WEST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if (x === GRID_WIDTH - 1 && y === 0) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n  } else if (x === GRID_WIDTH - 1 && y === GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if (y === 0 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n  } else if (x === 0 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if (y === GRID_LENGTH - 1 && x > 0 && x < GRID_WIDTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x + SOUTH][y]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  } else if (x === GRID_WIDTH - 1 && y > 0 && y < GRID_LENGTH - 1) {\r\n    neighbors.push(grid[x + NORTH][y]);\r\n    neighbors.push(grid[x][y + EAST]);\r\n    neighbors.push(grid[x][y + WEST]);\r\n  }\r\n  return neighbors;\r\n}\r\n\r\nexport function generateSideWalls(\r\n  wallNodes,\r\n  StartNode,\r\n  FinishNode,\r\n  width,\r\n  height\r\n) {\r\n  // left side\r\n  for (let row = 0; row < height; row++) {\r\n    if (\r\n      (row !== StartNode.row || StartNode.col !== 0) &&\r\n      (row !== FinishNode.row || FinishNode.col !== 0)\r\n    ) {\r\n      let node = {\r\n        row: row,\r\n        col: 0,\r\n      };\r\n      wallNodes.push(node);\r\n    }\r\n  }\r\n\r\n  // top side\r\n  for (let col = 0; col < width; col++) {\r\n    if (\r\n      (col !== StartNode.col || StartNode.row !== 0) &&\r\n      (col !== FinishNode.col || FinishNode.row !== 0)\r\n    ) {\r\n      let node = {\r\n        row: 0,\r\n        col: col,\r\n      };\r\n      wallNodes.push(node);\r\n    }\r\n  }\r\n\r\n  //right side\r\n  for (let row = 0; row < height; row++) {\r\n    if (\r\n      (row !== StartNode.row || StartNode.col !== width - 1) &&\r\n      (row !== FinishNode.row || FinishNode.col !== width - 1)\r\n    ) {\r\n      let node = {\r\n        row: row,\r\n        col: width - 1,\r\n      };\r\n      wallNodes.push(node);\r\n    }\r\n  }\r\n\r\n  // bottom side\r\n  for (let col = 0; col < width; col++) {\r\n    if (\r\n      (col !== StartNode.row || StartNode.col !== height - 1) &&\r\n      (col !== FinishNode.row || FinishNode.col !== height - 1)\r\n    ) {\r\n      let node = {\r\n        row: height - 1,\r\n        col: col,\r\n      };\r\n      wallNodes.push(node);\r\n    }\r\n  }\r\n}\r\n\r\n// Generate a random number netween lowNum and highNum\r\nexport function generateRandomNumber(lowNum, highNum) {\r\n  return Math.floor(Math.random() * (highNum - lowNum + 1)) + lowNum;\r\n}\r\n","import { getNeighbors } from \"../Functions/functions\";\r\n\r\n// depth first search\r\nexport function DFS(grid, startN, GRID_LENGTH, GRID_WIDTH) {\r\n  // push the first node into the array containing the nodes to be explored\r\n  let nodesToVisit = [];\r\n  nodesToVisit.push(startN);\r\n  let nodesVisited = [];\r\n  let path = helperDFS(\r\n    grid,\r\n    GRID_LENGTH,\r\n    GRID_WIDTH,\r\n    nodesToVisit,\r\n    nodesVisited\r\n  );\r\n  return path;\r\n}\r\n\r\n// recursive implementation\r\nfunction helperDFS(grid, GRID_LENGTH, GRID_WIDTH, nodesToVisit, nodesVisited) {\r\n  // if there are more nodes to visit and the node to explore next is the end node, return the path found\r\n  if (\r\n    nodesToVisit.length !== 0 &&\r\n    nodesToVisit[nodesToVisit.length - 1].isFinish\r\n  ) {\r\n    let path = {\r\n      visited: nodesVisited,\r\n      shortest: nodesToVisit,\r\n    };\r\n    return path;\r\n  }\r\n  // if there are no more nodes to visit, terminate\r\n  else if (nodesToVisit.length === 0) {\r\n    let path = {\r\n      visited: nodesVisited,\r\n      shortest: null,\r\n    };\r\n    return path;\r\n  } else {\r\n    // get the current node to be explored next\r\n    let currentNode = nodesToVisit[nodesToVisit.length - 1];\r\n    // get the nodes surrounding the current node\r\n    let neighbors = getNeighbors(currentNode, grid, GRID_LENGTH, GRID_WIDTH);\r\n    // for every neighbor\r\n    for (let i = 0; i < neighbors.length; i++) {\r\n      // if the neighbor is not a wall and is not the start node\r\n      if (!neighbors[i].isWall && !neighbors[i].isStart) {\r\n        // get the current neighbor\r\n        let neighbor = neighbors[i];\r\n        // if the node has not aleady been visited\r\n        if (!neighbor.isVisited) {\r\n          // set the previous node to be the current node\r\n          neighbor.previousNode = currentNode;\r\n          neighbor.isVisited = true;\r\n          // push the neighbor into the nodes to visit and the nodes visited array\r\n          nodesVisited.push(neighbor);\r\n          nodesToVisit.push(neighbor);\r\n          // recurse\r\n\r\n          // get the result\r\n          let recursiveResult = helperDFS(\r\n            grid,\r\n            GRID_LENGTH,\r\n            GRID_WIDTH,\r\n            nodesToVisit,\r\n            nodesVisited\r\n          );\r\n          if (recursiveResult === undefined) {\r\n            continue;\r\n          }\r\n          // return the result if not null and undefined\r\n          else if (\r\n            recursiveResult.shortest !== null &&\r\n            recursiveResult.shortest !== undefined\r\n          ) {\r\n            return recursiveResult;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // pop the last element out of the nodesToVisit array (element being explored)\r\n    nodesToVisit.pop();\r\n    return helperDFS(grid, GRID_LENGTH, GRID_WIDTH, nodesToVisit, nodesVisited);\r\n  }\r\n}\r\n","import {\r\n  generateSideWalls,\r\n  generateRandomNumber,\r\n} from \"../Functions/functions\";\r\n\r\nexport function RandomMaze(grid, StartNode, FinishNode) {\r\n  let height = grid.length;\r\n  let width = grid[0].length;\r\n  let wallNodes = [];\r\n  // first fill up all the sides with walls\r\n  generateSideWalls(wallNodes, StartNode, FinishNode, width, height);\r\n  for (let i = 1; i < height; i++) {\r\n    for (let j = 1; j < width; j++) {\r\n      let num = generateRandomNumber(0, 2);\r\n      if (num < 1) {\r\n        wallNodes.push({ row: i, col: j });\r\n      }\r\n    }\r\n  }\r\n  return wallNodes;\r\n}\r\n","import {\r\n  generateSideWalls,\r\n  generateRandomNumber,\r\n} from \"../Functions/functions\";\r\n\r\nexport function VerticalWalls(grid, StartNode, FinishNode) {\r\n  let height = grid.length;\r\n  let width = grid[0].length;\r\n  let wallNodes = [];\r\n  // first fill up all the sides with walls\r\n  generateSideWalls(wallNodes, StartNode, FinishNode, width, height);\r\n  for (let i = 1; i < width - 2; i++) {\r\n    for (let j = 1; j < height; j++) {\r\n      if (i % 2 == 0) {\r\n        let num = generateRandomNumber(0, 7);\r\n        if (num >= 1) {\r\n          wallNodes.push({ row: j, col: i });\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return wallNodes;\r\n}\r\n","import {\r\n  generateSideWalls,\r\n  generateRandomNumber,\r\n} from \"../Functions/functions\";\r\n\r\nexport function HorizontalWalls(grid, StartNode, FinishNode) {\r\n  let height = grid.length;\r\n  let width = grid[0].length;\r\n  let wallNodes = [];\r\n  // first fill up all the sides with walls\r\n  generateSideWalls(wallNodes, StartNode, FinishNode, width, height);\r\n  for (let i = 1; i < height - 2; i++) {\r\n    for (let j = 1; j < width - 1; j++) {\r\n      if (i % 2 == 0) {\r\n        let num = generateRandomNumber(0, 7);\r\n        if (num >= 1) {\r\n          wallNodes.push({ row: i, col: j });\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return wallNodes;\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport { dijkstra } from \"../Algos/Dijkstra\";\r\nimport { aStar } from \"../Algos/AStar\";\r\nimport { BFS } from \"../Algos/BreadthFirstSearch\";\r\nimport { DFS } from \"../Algos/DepthFirstSearch\";\r\nimport { GBFS } from \"../Algos/GreedyBestFirstSearch\";\r\nimport { RandomMaze } from \"../Maze/RandomMaze\";\r\nimport { VerticalWalls } from \"../Maze/VerticalWalls\";\r\nimport { HorizontalWalls } from \"../Maze/HorizontalWalls\";\r\nimport \"./Pathfinder.css\";\r\n\r\n/*\r\n  DISCLAIMER: \r\n    In the following application, I had to modify the state without using setState at times. This is because when the user is\r\n    dragging to make walls or running an algorithm, the component (the grid) would need to be rerendered so many times that it caused the application\r\n    to lag. The only way to avoid this lag was to change the state without causing the whole component to rerender. I know this is not the best practice\r\n    but I tried to use state correctly wherever I could.\r\n*/\r\n\r\nlet START_NODE_ROW = 10;\r\nlet START_NODE_COL = 10;\r\nlet FINISH_NODE_ROW = 10;\r\nlet FINISH_NODE_COL = 45;\r\n\r\nlet mouseIsPressed = false;\r\n\r\n// 0 = regular node, 1 = wall\r\nlet nodeBeforeEnter = -1;\r\n\r\nlet GRID_HEIGHT = 20;\r\nlet GRID_LENGTH = 50;\r\nexport default class Pathfinder extends Component {\r\n  // last algo: 0= A*, 1 = Greedy, 2= Dijkstra, 3=Breadth, 4 = Depth\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      gridClear: true,\r\n      beingUsed: false,\r\n      finishNodeMove: false,\r\n      startNodeMove: false,\r\n      finishNodeMove: false,\r\n      lastAlgo: -1,\r\n      algorithms: [\r\n        \"A* Algorithm\",\r\n        \"Greedy Best-First Search\",\r\n        \"Dijkstra's Algorithm\",\r\n        \"Breadth First Search\",\r\n        \"Depth First Search\",\r\n      ],\r\n      currentAlgo: \"Algorithms\",\r\n      speed: [\"Slow\", \"Normal\", \"Fast\"],\r\n      currentSpeed: \"Speed\",\r\n      speedValue: [100, 6, 4],\r\n      speedIndex: 1,\r\n      mazeAlgorithms: [\"Random Walls\", \"Vertical Walls\", \"Horizontal Walls\"],\r\n      mazeLabel: \"Generate Maze\",\r\n      startButtonPhrase: \"Choose Algorithm\",\r\n      gridBeingUsed: false,\r\n    };\r\n  }\r\n\r\n  // set the grid and also set up a mouseUp listener\r\n  componentDidMount() {\r\n    let windowWidth = window.screen.width;\r\n    let windowHeight = window.screen.height;\r\n    GRID_HEIGHT = Math.ceil((windowHeight - 250) / 25);\r\n    GRID_LENGTH = Math.ceil((windowWidth - 50) / 25);\r\n    START_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n    FINISH_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n    START_NODE_COL = Math.floor(GRID_LENGTH / 4);\r\n    FINISH_NODE_COL = Math.floor(GRID_LENGTH * (4 / 5));\r\n    const gridDrawn = this.formulateGrid();\r\n    this.setState({\r\n      grid: gridDrawn,\r\n    });\r\n    window.addEventListener(\"mouseup\", this.onMouseUp);\r\n  }\r\n\r\n  // detach mouseUp listener\r\n  componentWillUnmount() {\r\n    window.removeEventListener(\"mouseup\", this.onMouseUp);\r\n  }\r\n\r\n  // set mouseIsPressed to false, needed to on mouse up listeners because\r\n  // there was a bug with the one put on the node\r\n  onMouseUp = () => {\r\n    mouseIsPressed = false;\r\n  };\r\n\r\n  // if mouse enters the boundary of any node\r\n  handleMouseEnter = (row, col) => {\r\n    let node = this.state.grid[row][col];\r\n    // use this to take the state of the node back to what it was\r\n    if (node.isWall) {\r\n      nodeBeforeEnter = 1;\r\n    } else {\r\n      nodeBeforeEnter = 0;\r\n    }\r\n    // if dragging to make walls\r\n    if (\r\n      !node.isFinish &&\r\n      !node.isStart &&\r\n      mouseIsPressed &&\r\n      !this.state.startNodeMove &&\r\n      !this.state.finishNodeMove\r\n    ) {\r\n      if (!node.isWall) {\r\n        // turn the nodes into wall nodes\r\n        node.isWall = true;\r\n        node.isVisited = false;\r\n        document.getElementById(`node-${row}-${col}`).className =\r\n          \"node node-wall\";\r\n      } else {\r\n        // turn the wall nodes back into regular node\r\n        node.isWall = false;\r\n        node.isVisited = false;\r\n        document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n      }\r\n    } else if (this.state.startNodeMove && !node.isFinish) {\r\n      // if the start node is being dragged, set the nodes in the array accordingly and then\r\n      // set the row and column of where the start node is\r\n      node.isStart = true;\r\n      node.isWall = false;\r\n      document.getElementById(`node-${row}-${col}`).className =\r\n        \"node node-start\";\r\n      START_NODE_ROW = row;\r\n      START_NODE_COL = col;\r\n    } else if (this.state.finishNodeMove && !node.isStart) {\r\n      // if the finish node is moving, do the same thing as described above\r\n      node.isFinish = true;\r\n      node.isWall = false;\r\n      node.isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className =\r\n        \"node node-finish\";\r\n      FINISH_NODE_ROW = row;\r\n      FINISH_NODE_COL = col;\r\n      this.startAlgorithm(false);\r\n    }\r\n  };\r\n\r\n  // when the mouse leaves a certain node\r\n  handleMouseOut = (row, col) => {\r\n    let currentNode = this.state.grid[row][col];\r\n    // if the start node is moving\r\n    if (this.state.startNodeMove && !currentNode.isFinish) {\r\n      // set this node back into a regular node\r\n      currentNode.isStart = false;\r\n      currentNode.isFinish = false;\r\n      currentNode.isWall = false;\r\n      currentNode.isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n    } else if (this.state.finishNodeMove && !currentNode.isStart) {\r\n      // if finish node has moved out of this node, put node back into regular node\r\n      currentNode.isStart = false;\r\n      currentNode.isFinish = false;\r\n      currentNode.isWall = false;\r\n      currentNode.isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n    }\r\n    if (\r\n      nodeBeforeEnter === 1 &&\r\n      (this.state.startNodeMove || this.state.finishNodeMove)\r\n    ) {\r\n      // if the node was orinally a wall before the start/end node moved into it, set it\r\n      // back to a wall\r\n      currentNode.isWall = true;\r\n      currentNode.isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className =\r\n        \"node node-wall\";\r\n    }\r\n  };\r\n\r\n  handleMouseDown = (row, col) => {\r\n    // set the state of a particular node based on its current status of\r\n    // being a wall node or regular node\r\n    let currentNode = this.state.grid[row][col];\r\n\r\n    if (!currentNode.isFinish && !currentNode.isStart && !currentNode.isWall) {\r\n      // turn the node into a wall node and indicate that the mouse is currently being pressed\r\n      mouseIsPressed = true;\r\n      currentNode.isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className =\r\n        \"node node-wall\";\r\n      currentNode.isWall = true;\r\n    } else if (\r\n      !currentNode.isFinish &&\r\n      !currentNode.isStart &&\r\n      currentNode.isWall\r\n    ) {\r\n      // turn the node back into a regular node and indicate that the mouse is being pressed\r\n      mouseIsPressed = true;\r\n      currentNode.isVisited = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n      currentNode.isWall = false;\r\n    } else if (currentNode.isStart) {\r\n      // if the user is pressed on the start node, indicate that the start node is moving\r\n      this.setState({\r\n        startNodeMove: true,\r\n      });\r\n    } else if (currentNode.isFinish) {\r\n      // if the user is pressed on the finish  node, indicate that the finish node is moving\r\n      this.setState({\r\n        finishNodeMove: true,\r\n      });\r\n    }\r\n  };\r\n\r\n  handleMouseUp = (row, col) => {\r\n    // if the mouse is released\r\n    let currentNode = this.state.grid[row][col];\r\n    // the start and finish node are not being moved\r\n    this.setState({\r\n      startNodeMove: false,\r\n      finishNodeMove: false,\r\n    });\r\n    mouseIsPressed = false;\r\n\r\n    // if the start or end node is moving, update accoridingly\r\n    if (this.state.startNodeMove) {\r\n      START_NODE_ROW = row;\r\n      START_NODE_COL = col;\r\n    } else if (this.state.finishNodeMove) {\r\n      FINISH_NODE_ROW = row;\r\n      FINISH_NODE_COL = col;\r\n    }\r\n\r\n    // if the finish node is on top of the start node\r\n    if (\r\n      START_NODE_COL === FINISH_NODE_COL &&\r\n      START_NODE_ROW === FINISH_NODE_ROW\r\n    ) {\r\n      // reset the nodes to their original positions\r\n      currentNode.isFinish = false;\r\n      currentNode.isVisited = false;\r\n      currentNode.isStart = false;\r\n      currentNode.isWall = false;\r\n      document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n\r\n      START_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n      FINISH_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n      START_NODE_COL = Math.floor(GRID_LENGTH / 4);\r\n      FINISH_NODE_COL = Math.floor(GRID_LENGTH * (4 / 5));\r\n\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isWall = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isVisited = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isFinish = false;\r\n      this.state.grid[START_NODE_ROW][START_NODE_COL].isStart = true;\r\n      document.getElementById(\r\n        `node-${START_NODE_ROW}-${START_NODE_COL}`\r\n      ).className = \"node node-start\";\r\n\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isWall = false;\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isVisited = false;\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isFinish = true;\r\n      this.state.grid[FINISH_NODE_ROW][FINISH_NODE_COL].isStart = false;\r\n      document.getElementById(\r\n        `node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`\r\n      ).className = \"node node-finish\";\r\n    }\r\n  };\r\n\r\n  // visualize depth first search algo\r\n  visualizeDepthFirstSearch = (animate) => {\r\n    // only execute if the stat and end node are not moving\r\n    if (!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      // if the grid is not clear, clear the grid\r\n      if (!this.state.gridClear) {\r\n        this.clearPath();\r\n      }\r\n      this.setState({\r\n        lastAlgo: 4,\r\n      });\r\n      // disable all elements when visualizing\r\n      this.disableGrid();\r\n      // get the start node\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      // get the path returned\r\n      let path = DFS(this.state.grid, startNode, GRID_LENGTH, GRID_HEIGHT);\r\n      // visualize the path\r\n      if (path.shortest === null) {\r\n        this.displayAlgoNoPath(path.visited);\r\n      } else {\r\n        this.displayAlgo(path.visited, path.shortest, animate);\r\n      }\r\n    }\r\n  };\r\n\r\n  // visualize the greedy best first search algo\r\n  visualizeGreedyBestFirstSearch = (animate) => {\r\n    if (!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      if (!this.state.gridClear) {\r\n        this.clearPath();\r\n      }\r\n      this.setState({\r\n        lastAlgo: 1,\r\n      });\r\n      this.disableGrid();\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      let path = GBFS(\r\n        this.state.grid,\r\n        startNode,\r\n        GRID_LENGTH,\r\n        GRID_HEIGHT,\r\n        FINISH_NODE_ROW,\r\n        FINISH_NODE_COL\r\n      );\r\n      let shortestPath = path.shortest.reverse();\r\n      this.displayAlgo(path.visited, shortestPath, animate);\r\n    }\r\n  };\r\n\r\n  // this is pretty much the same thing as dijkstra's except we are not sorting\r\n  visualizeBreadthFirstSearch = (animate) => {\r\n    if (!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      if (!this.state.gridClear) {\r\n        this.clearPath();\r\n      }\r\n      this.setState({\r\n        lastAlgo: 3,\r\n      });\r\n      this.disableGrid();\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      let path = BFS(this.state.grid, startNode, GRID_LENGTH, GRID_HEIGHT);\r\n      let shortestPath = path.shortest.reverse();\r\n      this.displayAlgo(path.visited, shortestPath, animate);\r\n    }\r\n  };\r\n\r\n  // visualize A* algo\r\n  visualizeAStar = (animate) => {\r\n    if (!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      if (!this.state.gridClear) {\r\n        this.clearPath();\r\n      }\r\n      this.setState({\r\n        lastAlgo: 0,\r\n      });\r\n      this.disableGrid();\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      let path = aStar(\r\n        this.state.grid,\r\n        startNode,\r\n        GRID_LENGTH,\r\n        GRID_HEIGHT,\r\n        FINISH_NODE_ROW,\r\n        FINISH_NODE_COL\r\n      );\r\n      let shortestPath = path.shortest.reverse();\r\n      this.displayAlgo(path.visited, shortestPath, animate);\r\n    }\r\n  };\r\n\r\n  // visualize Dijkstra's algo\r\n  visualizeDijkstra = (animate) => {\r\n    if (!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      this.clearPath();\r\n      this.setState({\r\n        lastAlgo: 2,\r\n      });\r\n      this.disableGrid();\r\n      let startNode = this.state.grid[START_NODE_ROW][START_NODE_COL];\r\n      let path = dijkstra(this.state.grid, startNode, GRID_LENGTH, GRID_HEIGHT);\r\n      let shortestPath = path.shortest.reverse();\r\n      this.displayAlgo(path.visited, shortestPath, animate);\r\n    }\r\n  };\r\n\r\n  // if there is no path found, just display the path visited\r\n  displayAlgoNoPath(nodes) {\r\n    // grid is no longer clear\r\n    this.setState({\r\n      gridClear: false,\r\n    });\r\n    for (let i = 0; i <= nodes.length; i++) {\r\n      if (i === nodes.length) {\r\n        setTimeout(() => {\r\n          // enable all the elements again\r\n          this.enableGrid();\r\n          this.setState({\r\n            gridBeingUsed: false,\r\n          });\r\n        }, this.state.speedValue[this.state.speedIndex + 5] * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          // update the grid\r\n          const node = nodes[i];\r\n          if (!node.isStart && !node.isFinish) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-visited disabledNode\";\r\n          }\r\n        }, this.state.speedValue[this.state.speedIndex] * i);\r\n      }\r\n    }\r\n  }\r\n\r\n  // visualize the path found\r\n  displayAlgo(nodes, shortestPath, animate) {\r\n    for (let i = 0; i <= nodes.length; i++) {\r\n      if (i === nodes.length) {\r\n        // if the other elements are done updating, show the shortest path\r\n        if (animate) {\r\n          setTimeout(() => {\r\n            this.visualizeShortestPath(shortestPath, animate);\r\n          }, this.state.speedValue[this.state.speedIndex] * i);\r\n        } else {\r\n          this.visualizeShortestPath(shortestPath, animate);\r\n        }\r\n      } else {\r\n        if (animate) {\r\n          setTimeout(() => {\r\n            if (!node.isStart && !node.isFinish) {\r\n              document.getElementById(\r\n                `node-${node.row}-${node.col}`\r\n              ).className = \"node node-visited disabledNode\";\r\n            }\r\n          }, this.state.speedValue[this.state.speedIndex] * i);\r\n          const node = nodes[i];\r\n        } else {\r\n          const node = nodes[i];\r\n          if (!node.isStart && !node.isFinish) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-visited-no-animation\";\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // show the shortest path\r\n  visualizeShortestPath(shortestPath, animate) {\r\n    this.setState({\r\n      gridClear: false,\r\n    });\r\n\r\n    for (let j = 0; j <= shortestPath.length; j++) {\r\n      if (j === shortestPath.length) {\r\n        if (animate) {\r\n          setTimeout(() => {\r\n            this.enableGrid();\r\n            this.setState({\r\n              gridBeingUsed: false,\r\n            });\r\n          }, (this.state.speedValue[this.state.speedIndex] + 4) * j);\r\n        } else {\r\n          this.enableGrid();\r\n        }\r\n      } else {\r\n        if (animate) {\r\n          setTimeout(() => {\r\n            const node = shortestPath[j];\r\n            if (!node.isStart && !node.isFinish) {\r\n              document.getElementById(\r\n                `node-${node.row}-${node.col}`\r\n              ).className = \"node node-final-path disabledNode\";\r\n            }\r\n          }, (this.state.speedValue[this.state.speedIndex] + 4) * j);\r\n        } else {\r\n          const node = shortestPath[j];\r\n          if (!node.isStart && !node.isFinish) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-final-path-no-animation\";\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // clear the grid of all path nodes\r\n  clearPath = () => {\r\n    this.setState({\r\n      gridClear: true,\r\n      lastAlgo: -1,\r\n    });\r\n    nodeBeforeEnter = -1;\r\n    for (let i = 0; i < GRID_HEIGHT; i++) {\r\n      for (let j = 0; j < GRID_LENGTH; j++) {\r\n        if (i === START_NODE_ROW && j === START_NODE_COL) {\r\n          document.getElementById(`node-${i}-${j}`).className =\r\n            \"node node-start\";\r\n          this.state.grid[i][j].distance = Infinity;\r\n          this.state.grid[i][j].isVisited = false;\r\n          this.state.grid[i][j].isWall = false;\r\n          this.state.grid[i][j].previousNode = null;\r\n        } else if (i === FINISH_NODE_ROW && j === FINISH_NODE_COL) {\r\n          document.getElementById(`node-${i}-${j}`).className =\r\n            \"node node-finish\";\r\n          this.state.grid[i][j].distance = Infinity;\r\n          this.state.grid[i][j].isVisited = false;\r\n          this.state.grid[i][j].isWall = false;\r\n          this.state.grid[i][j].previousNode = null;\r\n        } else if (\r\n          this.state.grid[i][j].isVisited &&\r\n          !this.state.grid[i][j].isFinish\r\n        ) {\r\n          document.getElementById(`node-${i}-${j}`).className = \"node\";\r\n          this.state.grid[i][j].distance = Infinity;\r\n          this.state.grid[i][j].isVisited = false;\r\n          this.state.grid[i][j].isWall = false;\r\n          this.state.grid[i][j].previousNode = null;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  updateCurrentAlgo = (event) => {\r\n    this.setState({\r\n      currentAlgo: event.target.value,\r\n      startButtonPhrase: \"Visualize\",\r\n    });\r\n  };\r\n\r\n  // clear the grid of all wall and path nodes\r\n  clearGrid = () => {\r\n    if (!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      this.setState({\r\n        gridClear: true,\r\n        lastAlgo: -1,\r\n      });\r\n      nodeBeforeEnter = -1;\r\n      for (let i = 0; i < GRID_HEIGHT; i++) {\r\n        for (let j = 0; j < GRID_LENGTH; j++) {\r\n          if (i === START_NODE_ROW && j === START_NODE_COL) {\r\n            document.getElementById(`node-${i}-${j}`).className =\r\n              \"node node-start\";\r\n            this.state.grid[i][j].isStart = true;\r\n          } else if (i === FINISH_NODE_ROW && j === FINISH_NODE_COL) {\r\n            document.getElementById(`node-${i}-${j}`).className =\r\n              \"node node-finish\";\r\n            this.state.grid[i][j].isFinish = true;\r\n          } else {\r\n            document.getElementById(`node-${i}-${j}`).className = \"node\";\r\n          }\r\n          this.state.grid[i][j].distance = Infinity;\r\n          this.state.grid[i][j].isVisited = false;\r\n          this.state.grid[i][j].isWall = false;\r\n          this.state.grid[i][j].previousNode = null;\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  startAlgorithm = (animate) => {\r\n    if (\r\n      this.state.currentSpeed == \"Speed\" &&\r\n      this.state.currentAlgo !== \"Algorithms\"\r\n    ) {\r\n      this.forceUpdateSpeed();\r\n    }\r\n    if (\r\n      this.state.currentAlgo !== \"Algorithms\" &&\r\n      animate &&\r\n      !this.state.startNodeMove &&\r\n      !this.state.finishNodeMove\r\n    ) {\r\n      this.setState({\r\n        gridBeingUsed: true,\r\n      });\r\n    }\r\n    let algo = this.state.currentAlgo;\r\n    if (algo === \"A* Algorithm\") {\r\n      this.visualizeAStar(animate);\r\n    } else if (algo === \"Greedy Best-First Search\") {\r\n      this.visualizeGreedyBestFirstSearch(animate);\r\n    } else if (algo === \"Dijkstra's Algorithm\") {\r\n      this.visualizeDijkstra(animate);\r\n    } else if (algo === \"Breadth First Search\") {\r\n      this.visualizeBreadthFirstSearch(animate);\r\n    } else if (algo === \"Depth First Search\") {\r\n      this.visualizeDepthFirstSearch(animate);\r\n    }\r\n  };\r\n\r\n  // generate a maze to be displayed\r\n  generateMaze = async (event) => {\r\n    if (!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      let type = event.target.value;\r\n      this.clearGrid();\r\n      this.disableGrid();\r\n      this.setState({\r\n        gridBeingUsed: true,\r\n      });\r\n      if (type === \"Random Walls\") {\r\n        let walls = RandomMaze(\r\n          this.state.grid,\r\n          { row: START_NODE_ROW, col: START_NODE_COL },\r\n          { row: FINISH_NODE_ROW, col: FINISH_NODE_COL }\r\n        );\r\n        this.displayMaze(walls);\r\n      } else if (type === \"Vertical Walls\") {\r\n        let walls = VerticalWalls(\r\n          this.state.grid,\r\n          { row: START_NODE_ROW, col: START_NODE_COL },\r\n          { row: FINISH_NODE_ROW, col: FINISH_NODE_COL }\r\n        );\r\n        this.displayMaze(walls);\r\n      } else if (type === \"Horizontal Walls\") {\r\n        let walls = HorizontalWalls(\r\n          this.state.grid,\r\n          { row: START_NODE_ROW, col: START_NODE_COL },\r\n          { row: FINISH_NODE_ROW, col: FINISH_NODE_COL }\r\n        );\r\n        this.displayMaze(walls);\r\n      }\r\n    }\r\n  };\r\n\r\n  displayMaze = (nodes) => {\r\n    for (let i = 0; i <= nodes.length; i++) {\r\n      if (i == nodes.length) {\r\n        setTimeout(() => {\r\n          this.enableGrid();\r\n          this.setState({\r\n            gridBeingUsed: false,\r\n          });\r\n        }, 7 * i);\r\n      } else {\r\n        setTimeout(() => {\r\n          let node = nodes[i];\r\n          if (\r\n            (node.row !== FINISH_NODE_ROW || node.col !== FINISH_NODE_COL) &&\r\n            (node.row !== START_NODE_ROW || node.col !== START_NODE_COL)\r\n          ) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-wall\";\r\n            this.state.grid[node.row][node.col].isVisited = false;\r\n            this.state.grid[node.row][node.col].isWall = true;\r\n          }\r\n        }, 7 * i);\r\n      }\r\n    }\r\n  };\r\n\r\n  updateSpeed = (event) => {\r\n    let speed = event.target.value;\r\n    if (speed === \"Slow\") {\r\n      this.setState({\r\n        speedIndex: 0,\r\n        currentSpeed: \"Slow\",\r\n      });\r\n    } else if (speed === \"Normal\") {\r\n      this.setState({\r\n        speedIndex: 1,\r\n        currentSpeed: \"Normal\",\r\n      });\r\n    } else if (speed === \"Fast\") {\r\n      this.setState({\r\n        speedIndex: 2,\r\n        currentSpeed: \"Fast\",\r\n      });\r\n    }\r\n  };\r\n\r\n  // If the user does not choose a speed, choose normal for them\r\n  forceUpdateSpeed = () => {\r\n    this.setState({\r\n      speedIndex: 1,\r\n      currentSpeed: \"Normal\",\r\n    });\r\n  };\r\n\r\n  // Set the grid to how it was when game first started\r\n  resetGrid = () => {\r\n    if (!this.state.startNodeMove && !this.state.finishNodeMove) {\r\n      this.clearGrid();\r\n      START_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n      FINISH_NODE_ROW = Math.floor(GRID_HEIGHT / 2);\r\n      START_NODE_COL = Math.floor(GRID_LENGTH / 4);\r\n      FINISH_NODE_COL = Math.floor(GRID_LENGTH * (4 / 5));\r\n      const gridDrawn = this.formulateGrid();\r\n      this.setState({\r\n        grid: gridDrawn,\r\n        speedIndex: 1,\r\n        currentAlgo: \"Algorithms\",\r\n        currentSpeed: \"Speed\",\r\n        mazeLabel: \"Generate Maze\",\r\n        startButtonPhrase: \"Choose Algorithm\",\r\n      });\r\n    }\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <div className=\"button-container\">\r\n          <text className=\"header\">Pathfinding Visualized</text>\r\n          <div className=\"buttons\">\r\n            <select\r\n              className={`${\r\n                this.state.gridBeingUsed ? \"dropDownDisabled\" : \"dropDown\"\r\n              }`}\r\n              id=\"pathfinding-algorithm-selection\"\r\n              value={this.state.currentAlgo}\r\n              onChange={this.updateCurrentAlgo}\r\n              disabled={this.state.gridBeingUsed ? true : false}\r\n            >\r\n              <option selected disabled hidden>\r\n                Algorithms\r\n              </option>\r\n              {this.state.algorithms.map((algorithms) => (\r\n                <option key={algorithms} value={algorithms}>\r\n                  {algorithms}\r\n                </option>\r\n              ))}\r\n            </select>\r\n            <select\r\n              className={`${\r\n                this.state.gridBeingUsed ? \"dropDownDisabled\" : \"dropDown\"\r\n              }`}\r\n              id=\"maze-algorithm-selection\"\r\n              value={\"Generate Walls\"}\r\n              onChange={this.generateMaze}\r\n              disabled={this.state.gridBeingUsed ? true : false}\r\n            >\r\n              <option selected disabled hidden>\r\n                Generate Walls\r\n              </option>\r\n              {this.state.mazeAlgorithms.map((maze) => (\r\n                <option key={maze} value={maze}>\r\n                  {maze}\r\n                </option>\r\n              ))}\r\n            </select>\r\n            <select\r\n              value={this.state.currentSpeed}\r\n              className={`${\r\n                this.state.gridBeingUsed ? \"dropDownDisabled\" : \"dropDown\"\r\n              }`}\r\n              id=\"speed-selection\"\r\n              onChange={this.updateSpeed}\r\n              disabled={this.state.gridBeingUsed ? true : false}\r\n            >\r\n              <option selected disabled hidden>\r\n                Speed\r\n              </option>\r\n              {this.state.speed.map((speed) => (\r\n                <option key={speed} value={speed}>\r\n                  {speed}\r\n                </option>\r\n              ))}\r\n            </select>\r\n            <button\r\n              className={`button button-start ${\r\n                this.state.gridBeingUsed ? \"button-start-disabled\" : \"\"\r\n              }`}\r\n              id=\"start-algorithm\"\r\n              onClick={() => this.startAlgorithm(true)}\r\n              disabled={this.state.gridBeingUsed ? true : false}\r\n            >\r\n              {this.state.startButtonPhrase}\r\n            </button>\r\n            <button\r\n              id=\"clear-grid\"\r\n              className={`button ${\r\n                this.state.gridBeingUsed\r\n                  ? \"button-clear-disabled\"\r\n                  : \"button-clear\"\r\n              }`}\r\n              onClick={this.clearGrid}\r\n              disabled={this.state.gridBeingUsed ? true : false}\r\n            >\r\n              Clear Grid\r\n            </button>\r\n            <button\r\n              id=\"reset-button\"\r\n              className={`button ${\r\n                this.state.gridBeingUsed\r\n                  ? \"button-clear-disabled\"\r\n                  : \"button-clear\"\r\n              }`}\r\n              onClick={this.resetGrid}\r\n              disabled={this.state.gridBeingUsed ? true : false}\r\n            >\r\n              Reset\r\n            </button>\r\n          </div>\r\n        </div>\r\n        <div className=\"gridAndLegend\">\r\n          <div className=\"legend\">\r\n            <div className=\"fakeNode fakeNodeStart firstFakeNode\"></div>\r\n            <label className=\"fakeNodeLabel\">Start Node</label>\r\n            <div className=\"fakeNode fakeNodeEnd\"></div>\r\n            <label className=\"fakeNodeLabel\">End Node</label>\r\n            <div className=\"fakeNode fakeNodeBlock\"></div>\r\n            <label className=\"fakeNodeLabel\">Wall Node</label>\r\n            <div className=\"fakeNode\"></div>\r\n            <label className=\"fakeNodeLabel\">Unvisted Node</label>\r\n            <div className=\"fakeNode fakeNodeExploredFirst\"></div>\r\n            <div className=\"fakeNode fakeNodeExploredSecond\"></div>\r\n            <label className=\"fakeNodeLabel\">Explored Node</label>\r\n            <div className=\"fakeNode fakeNodeShortestPath\"></div>\r\n            <label className=\"fakeNodeLabel\">Path Found Node</label>\r\n          </div>\r\n          <div id=\"gridNodes\" className=\"grid\">\r\n            {this.state.grid.map((row, rowIdx) => {\r\n              return (\r\n                <div key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const { row, col, isFinish, isStart, isWall } = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        col={col}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                        onMouseOut={(row, col) => this.handleMouseOut(row, col)}\r\n                        row={row}\r\n                      />\r\n                    );\r\n                  })}\r\n                </div>\r\n              );\r\n            })}\r\n          </div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n\r\n  disableGrid() {\r\n    for (let i = 0; i < GRID_HEIGHT; i++) {\r\n      for (let j = 0; j < GRID_LENGTH; j++) {\r\n        document.getElementById(`node-${i}-${j}`).classList.add(\"disabledNode\");\r\n      }\r\n    }\r\n  }\r\n\r\n  enableGrid() {\r\n    for (let i = 0; i < GRID_HEIGHT; i++) {\r\n      for (let j = 0; j < GRID_LENGTH; j++) {\r\n        document\r\n          .getElementById(`node-${i}-${j}`)\r\n          .classList.remove(\"disabledNode\");\r\n      }\r\n    }\r\n  }\r\n\r\n  // generate the beginning grid\r\n  formulateGrid = () => {\r\n    // draw a grid onto the screen\r\n    const nodes = [];\r\n    for (let i = 0; i < GRID_HEIGHT; i++) {\r\n      const row = [];\r\n      for (let j = 0; j < GRID_LENGTH; j++) {\r\n        row.push(this.createNode(j, i));\r\n      }\r\n      nodes.push(row);\r\n    }\r\n    return nodes;\r\n  };\r\n\r\n  // create a node\r\n  createNode = (col, row) => {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n    };\r\n  };\r\n}\r\n","import { getNeighbors } from \"../Functions/functions\";\r\n\r\n\r\n// Greedier version of A*\r\nexport function GBFS(\r\n  grid,\r\n  startN,\r\n  GRID_LENGTH,\r\n  GRID_WIDTH,\r\n  FINISH_NODE_ROW,\r\n  FINISH_NODE_COL\r\n) {\r\n  let nodesToVisit = [];\r\n  let visitedNodes = [];\r\n  let shortestPath = [];\r\n  let startNode = grid[startN.row][startN.col];\r\n\r\n  startNode.isVisited = true;\r\n  nodesToVisit.push(startNode);\r\n\r\n  while (nodesToVisit.length !== 0) {\r\n    nodesToVisit.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    let currentNode = nodesToVisit.shift();\r\n    if (currentNode.isFinish) {\r\n      shortestPath.push(currentNode);\r\n      let current = currentNode.previousNode;\r\n      while (current !== null) {\r\n        shortestPath.push(current);\r\n        current = current.previousNode;\r\n      }\r\n      break;\r\n    }\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    let surroundingNodes = getNeighbors(\r\n      currentNode,\r\n      grid,\r\n      GRID_LENGTH,\r\n      GRID_WIDTH\r\n    );\r\n    for (let i = 0; i < surroundingNodes.length; i++) {\r\n      if (!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n        let neighbor = surroundingNodes[i];\r\n        if (!neighbor.isVisited) {\r\n          // get the distance between current node and end node (H cost)\r\n          let distanceFromEndX = Math.abs(FINISH_NODE_ROW - neighbor.row) * 10;\r\n          let distanceFromEndY = Math.abs(FINISH_NODE_COL - neighbor.col) * 10;\r\n          let distanceFromEndNode = distanceFromEndX + distanceFromEndY;\r\n\r\n          // Greedy best first search only takes into account distance from end node\r\n          // when calculating cost. Thus f(n) = h(n)\r\n          neighbor.previousNode = currentNode;\r\n          neighbor.distance = distanceFromEndNode;\r\n          neighbor.isVisited = true;\r\n          nodesToVisit.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    visitedNodes.push(currentNode);\r\n  }\r\n  let path = {\r\n    visited: visitedNodes,\r\n    shortest: shortestPath,\r\n  };\r\n  return path;\r\n}\r\n","import { getNeighbors } from \"../Functions/functions\";\r\n\r\n// Breadth first search\r\nexport function BFS(grid, startN, GRID_LENGTH, GRID_WIDTH) {\r\n  let nodesToVisit = [];\r\n  let visitedNodes = [];\r\n  let shortestPath = [];\r\n  let startNode = grid[startN.row][startN.col];\r\n\r\n  // push the start node into the array to be explored\r\n  startNode.distance = 0;\r\n  startNode.isVisited = true;\r\n  nodesToVisit.push(startNode);\r\n\r\n  // while there are still nodes to be explored\r\n  while (nodesToVisit.length !== 0) {\r\n    // take the first node from the front of the array\r\n    let currentNode = nodesToVisit.shift();\r\n    if (currentNode.isFinish) {\r\n      //calculate shortest path\r\n      shortestPath.push(currentNode);\r\n      let current = currentNode.previousNode;\r\n      while (current !== null) {\r\n        shortestPath.push(current);\r\n        current = current.previousNode;\r\n      }\r\n      break;\r\n    }\r\n    // if the node is a wall, dont do anything\r\n    if (currentNode.isWall) continue;\r\n\r\n    //get the neighbors surrounding the node\r\n    let surroundingNodes = getNeighbors(\r\n      currentNode,\r\n      grid,\r\n      GRID_LENGTH,\r\n      GRID_WIDTH\r\n    );\r\n\r\n    // for each surrounding node\r\n    for (let i = 0; i < surroundingNodes.length; i++) {\r\n      // if the node is not a wall and is not the start node\r\n      if (!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n        let neighbor = surroundingNodes[i];\r\n        // if the node has not been visited\r\n        if (!neighbor.isVisited) {\r\n          // calculate distance and push node into the array of nodes to be visited\r\n          neighbor.previousNode = currentNode;\r\n          neighbor.distance = currentNode.distance + 1;\r\n          neighbor.isVisited = true;\r\n          nodesToVisit.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    // done with node\r\n    visitedNodes.push(currentNode);\r\n  }\r\n  // return the path and the shortest path\r\n  let path = {\r\n    visited: visitedNodes,\r\n    shortest: shortestPath,\r\n  };\r\n  return path;\r\n}\r\n","import { getNeighbors } from \"../Functions/functions\";\r\n\r\n// A* algo\r\nexport function aStar(\r\n  grid,\r\n  startN,\r\n  GRID_LENGTH,\r\n  GRID_WIDTH,\r\n  FINISH_NODE_ROW,\r\n  FINISH_NODE_COL\r\n) {\r\n  let nodesToVisit = [];\r\n  let visitedNodes = [];\r\n  let shortestPath = [];\r\n  let startNode = grid[startN.row][startN.col];\r\n\r\n  // push the start node into the array to be explored\r\n  startNode.distance = 0;\r\n  startNode.gCost = 0;\r\n  startNode.isVisited = true;\r\n  nodesToVisit.push(startNode);\r\n\r\n  // while array containing the nodes to be explored is not empty\r\n  while (nodesToVisit.length !== 0) {\r\n    // sort the array\r\n    nodesToVisit.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    // take the first element out of the array\r\n    let currentNode = nodesToVisit.shift();\r\n    // check if the current node is the finish node\r\n    if (currentNode.isFinish) {\r\n      let current = currentNode;\r\n      // if it is, get the shortest path\r\n      while (current !== null) {\r\n        shortestPath.push(current);\r\n        current = current.previousNode;\r\n      }\r\n      // end the loop\r\n      break;\r\n    }\r\n    // if the currenNode is a wall, dont do anything\r\n    if (currentNode.isWall) continue;\r\n\r\n    // get the nodes surrounding the currentNode\r\n    let surroundingNodes = getNeighbors(\r\n      currentNode,\r\n      grid,\r\n      GRID_LENGTH,\r\n      GRID_WIDTH\r\n    );\r\n\r\n    // for every neighbor\r\n    for (let i = 0; i < surroundingNodes.length; i++) {\r\n      // if the node is not a wall and is not the start node\r\n      if (!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n        let neighbor = surroundingNodes[i];\r\n        // if the neighbor has not already been visited\r\n        if (!neighbor.isVisited) {\r\n          // get the distance between current node and end node (H cost)\r\n          let distanceFromEndX = Math.abs(FINISH_NODE_ROW - neighbor.row) * 10;\r\n          let distanceFromEndY = Math.abs(FINISH_NODE_COL - neighbor.col) * 10;\r\n          let distanceFromEndNode = distanceFromEndX + distanceFromEndY;\r\n\r\n          // set the previous node equal to the current node\r\n          neighbor.previousNode = currentNode;\r\n\r\n          // get the g cost, determined by a nodes distance from the start node\r\n          let distanceFromStartX =\r\n            Math.abs(currentNode.row - neighbor.row) * 10;\r\n          let distanceFromStartY =\r\n            Math.abs(currentNode.col - neighbor.col) * 10;\r\n          neighbor.gCost =\r\n            currentNode.gCost + distanceFromStartX + distanceFromStartY;\r\n\r\n          // A* is calculated by adding Gcost with Hcost\r\n          neighbor.distance = neighbor.gCost + distanceFromEndNode;\r\n          neighbor.isVisited = true;\r\n          nodesToVisit.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    // push currentNode into the visited array\r\n    visitedNodes.push(currentNode);\r\n  }\r\n  // return the path and the shortest path\r\n  let path = {\r\n    visited: visitedNodes,\r\n    shortest: shortestPath,\r\n  };\r\n  return path;\r\n}\r\n","import { getNeighbors } from \"../Functions/functions\";\r\n\r\nexport function dijkstra(grid, startN, GRID_LENGTH, GRID_WIDTH) {\r\n  let nodesToVisit = [];\r\n  let visitedNodes = [];\r\n  let shortestPath = [];\r\n\r\n  // set the start node in the grid\r\n  let startNode = grid[startN.row][startN.col];\r\n\r\n  // push the first node into the array of nodes to explore\r\n  startNode.distance = 0;\r\n  startNode.isVisited = true;\r\n  nodesToVisit.push(startNode);\r\n\r\n  // while there are more nodes to explore\r\n  while (nodesToVisit.length !== 0) {\r\n    // sort\r\n    nodesToVisit.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n    // take the first node out\r\n    let currentNode = nodesToVisit.shift();\r\n    // if its the finish node, return\r\n    if (currentNode.isFinish) {\r\n      shortestPath.push(currentNode);\r\n      let current = currentNode.previousNode;\r\n      while (current !== null) {\r\n        shortestPath.push(current);\r\n        current = current.previousNode;\r\n      }\r\n      break;\r\n    }\r\n    if (currentNode.isWall) continue;\r\n    let surroundingNodes = getNeighbors(\r\n      currentNode,\r\n      grid,\r\n      GRID_LENGTH,\r\n      GRID_WIDTH\r\n    );\r\n\r\n    for (let i = 0; i < surroundingNodes.length; i++) {\r\n      if (!surroundingNodes[i].isWall && !surroundingNodes[i].isStart) {\r\n        let neighbor = surroundingNodes[i];\r\n        if (!neighbor.isVisited) {\r\n          // set previous node accordingly and push all of neighbors into the array to be visited\r\n          neighbor.previousNode = currentNode;\r\n          neighbor.distance = currentNode.distance + 1;\r\n          neighbor.isVisited = true;\r\n          nodesToVisit.push(neighbor);\r\n        }\r\n      }\r\n    }\r\n    visitedNodes.push(currentNode);\r\n  }\r\n  // return the path and shortest path calculated\r\n  let path = {\r\n    visited: visitedNodes,\r\n    shortest: shortestPath,\r\n  };\r\n  return path;\r\n}\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport Pathfinder from \"./PathfinderVisualization/Pathfinder\";\r\n\r\n/*\r\n  Big thanks to Clement Mihailescu, who inspired me to do this project!\r\n\r\n  His youtube channel can be found here: https://www.youtube.com/channel/UCaO6VoaYJv4kS-TQO_M-N_g\r\n*/\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"app\">\r\n      <Pathfinder />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}